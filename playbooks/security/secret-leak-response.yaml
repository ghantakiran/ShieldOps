# ShieldOps Security Playbook: Secret Leak Incident Response
# Triggered when: Hardcoded secrets detected in source code

name: secret-leak-response
version: "1.0"
description: "Respond to detected secret leaks in source code repositories"
trigger:
  scanner_type: ["git_secrets"]
  severity: ["critical", "high", "medium"]

investigation:
  steps:
    - name: identify_secret_type
      action: classify_secret
      description: "Determine what type of secret was leaked"
      extract:
        - secret_type  # aws_key, api_token, db_password, tls_cert, ssh_key
        - secret_scope  # production, staging, development
        - exposure_duration

    - name: check_commit_history
      action: query_git
      description: "Determine if the secret was in public/shared commits"
      extract:
        - commit_hash
        - commit_author
        - branch_name
        - is_merged_to_main
        - pushed_to_remote

    - name: check_access_logs
      action: query_audit_logs
      description: "Check if the compromised credential was used by unauthorized parties"
      extract:
        - unauthorized_access_detected
        - access_log_entries

    - name: identify_consumers
      action: query_inventory
      description: "Find all services that use this credential"
      extract:
        - consuming_services
        - service_count

remediation:
  decision_tree:
    - condition: "secret_type == 'aws_key' AND pushed_to_remote"
      action: emergency_rotation
      risk_level: critical
      params:
        steps:
          - "Immediately deactivate the compromised AWS access key"
          - "Generate new access key pair"
          - "Update all consuming services via secrets manager"
          - "Audit CloudTrail for unauthorized usage"
          - "Remove secret from git history using BFG or git filter-repo"

    - condition: "secret_type == 'db_password'"
      action: rotate_database_credential
      risk_level: high
      params:
        steps:
          - "Create new database user with same permissions"
          - "Update connection strings in secrets manager"
          - "Rotate consuming services to new credential"
          - "Delete old database user"
          - "Purge secret from git history"

    - condition: "secret_type == 'api_token'"
      action: rotate_api_token
      risk_level: high
      params:
        steps:
          - "Revoke the compromised API token"
          - "Generate new token with same scopes"
          - "Update all consumers via env vars or secrets manager"
          - "Purge from git history"

    - condition: "default"
      action: generic_secret_rotation
      risk_level: medium
      params:
        steps:
          - "Rotate the compromised credential"
          - "Update all consumers"
          - "Remove from source code"
          - "Add to .gitignore or pre-commit hooks"

  post_remediation:
    - action: add_pre_commit_hook
      description: "Install gitleaks pre-commit hook to prevent future leaks"
    - action: update_gitignore
      description: "Ensure secret file patterns are in .gitignore"
    - action: enforce_secrets_manager
      description: "Migrate to vault/secrets manager for this credential type"

validation:
  checks:
    - name: secret_rotated
      description: "Verify old credential no longer works"
      action: test_old_credential
      expected: "authentication failure"
      timeout_seconds: 60

    - name: services_healthy
      description: "Verify all consuming services work with new credential"
      action: health_check
      expected: "all services healthy"
      timeout_seconds: 300

    - name: git_history_clean
      description: "Verify secret removed from git history"
      action: scan_git_history
      expected: "no secrets detected"
      timeout_seconds: 120

  on_failure:
    action: escalate_security_incident
    escalation_channel: "#security-incident"
