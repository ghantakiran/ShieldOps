"""Automated playbook application from learning cycles.

Closes the autonomous feedback loop: Learning Agent discovers improvements,
and the AutoApplier applies low-risk changes automatically while routing
higher-risk changes through approval workflows.
"""

from __future__ import annotations

from datetime import UTC, datetime
from enum import StrEnum
from typing import TYPE_CHECKING, Any
from uuid import uuid4

import structlog
from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from shieldops.playbooks.loader import PlaybookLoader

logger = structlog.get_logger()


class ApprovalPolicy(StrEnum):
    """Approval levels for learning recommendations."""

    AUTO_APPROVE = "auto_approve"
    REQUIRE_REVIEW = "require_review"
    MANUAL_ONLY = "manual_only"


class RecommendationStatus(StrEnum):
    """Status of a learning recommendation."""

    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    AUTO_APPLIED = "auto_applied"
    FAILED = "failed"


class RecommendationType(StrEnum):
    """Types of learning recommendations."""

    THRESHOLD_ADJUSTMENT = "threshold_adjustment"
    PLAYBOOK_UPDATE = "playbook_update"
    NEW_PLAYBOOK = "new_playbook"
    ALERT_TUNING = "alert_tuning"
    PATTERN_RULE = "pattern_rule"


class LearningRecommendation(BaseModel):
    """A recommendation generated by the Learning Agent."""

    id: str = Field(default_factory=lambda: f"rec-{uuid4().hex[:12]}")
    recommendation_type: RecommendationType
    title: str
    description: str
    risk_score: float = 0.0  # 0.0 (safe) to 1.0 (dangerous)
    confidence: float = 0.0
    source_learning_id: str = ""
    target_playbook: str | None = None
    changes: dict[str, Any] = Field(default_factory=dict)
    status: RecommendationStatus = RecommendationStatus.PENDING
    approval_policy: ApprovalPolicy = ApprovalPolicy.REQUIRE_REVIEW
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    applied_at: datetime | None = None
    reviewed_by: str | None = None
    rejection_reason: str | None = None


class AutoApplyResult(BaseModel):
    """Result of an auto-apply operation."""

    recommendation_id: str
    success: bool
    applied_changes: dict[str, Any] = Field(default_factory=dict)
    error: str | None = None
    applied_at: datetime = Field(default_factory=lambda: datetime.now(UTC))


class PlaybookAutoApplier:
    """Applies learning recommendations with risk-based approval policies.

    Low-risk threshold adjustments are auto-applied. Playbook modifications
    require human review. New playbooks are manual-only by default.
    """

    # Risk thresholds for auto-approval
    AUTO_APPROVE_MAX_RISK = 0.3
    REVIEW_MAX_RISK = 0.7

    def __init__(
        self,
        playbook_loader: PlaybookLoader | None = None,
        auto_apply_enabled: bool = True,
    ) -> None:
        self._loader = playbook_loader
        self._auto_apply_enabled = auto_apply_enabled
        self._recommendations: dict[str, LearningRecommendation] = {}
        self._auto_applied: list[AutoApplyResult] = []

    def classify_approval_policy(self, recommendation: LearningRecommendation) -> ApprovalPolicy:
        """Determine the approval policy based on recommendation type and risk."""
        if recommendation.risk_score > self.REVIEW_MAX_RISK:
            return ApprovalPolicy.MANUAL_ONLY

        if recommendation.recommendation_type == RecommendationType.NEW_PLAYBOOK:
            return ApprovalPolicy.MANUAL_ONLY

        if recommendation.recommendation_type == RecommendationType.PLAYBOOK_UPDATE:
            return ApprovalPolicy.REQUIRE_REVIEW

        if (
            recommendation.recommendation_type == RecommendationType.THRESHOLD_ADJUSTMENT
            and recommendation.risk_score <= self.AUTO_APPROVE_MAX_RISK
            and recommendation.confidence >= 0.8
        ):
            return ApprovalPolicy.AUTO_APPROVE

        if (
            recommendation.recommendation_type == RecommendationType.ALERT_TUNING
            and recommendation.risk_score <= self.AUTO_APPROVE_MAX_RISK
        ):
            return ApprovalPolicy.AUTO_APPROVE

        return ApprovalPolicy.REQUIRE_REVIEW

    def submit_recommendation(
        self, recommendation: LearningRecommendation
    ) -> LearningRecommendation:
        """Submit a learning recommendation for processing."""
        recommendation.approval_policy = self.classify_approval_policy(recommendation)
        self._recommendations[recommendation.id] = recommendation

        logger.info(
            "recommendation_submitted",
            rec_id=recommendation.id,
            type=recommendation.recommendation_type,
            risk=recommendation.risk_score,
            policy=recommendation.approval_policy,
        )

        # Auto-apply if policy allows and auto-apply is enabled
        if (
            self._auto_apply_enabled
            and recommendation.approval_policy == ApprovalPolicy.AUTO_APPROVE
        ):
            result = self._apply_recommendation(recommendation)
            if result.success:
                recommendation.status = RecommendationStatus.AUTO_APPLIED
                recommendation.applied_at = result.applied_at
            else:
                recommendation.status = RecommendationStatus.FAILED

        return recommendation

    def approve_recommendation(
        self, recommendation_id: str, reviewer: str
    ) -> LearningRecommendation | None:
        """Approve a pending recommendation and apply it."""
        rec = self._recommendations.get(recommendation_id)
        if rec is None:
            return None

        if rec.status != RecommendationStatus.PENDING:
            return rec

        rec.reviewed_by = reviewer
        result = self._apply_recommendation(rec)

        if result.success:
            rec.status = RecommendationStatus.APPROVED
            rec.applied_at = result.applied_at
        else:
            rec.status = RecommendationStatus.FAILED

        logger.info(
            "recommendation_approved",
            rec_id=recommendation_id,
            reviewer=reviewer,
            success=result.success,
        )
        return rec

    def reject_recommendation(
        self, recommendation_id: str, reviewer: str, reason: str = ""
    ) -> LearningRecommendation | None:
        """Reject a pending recommendation."""
        rec = self._recommendations.get(recommendation_id)
        if rec is None:
            return None

        if rec.status != RecommendationStatus.PENDING:
            return rec

        rec.status = RecommendationStatus.REJECTED
        rec.reviewed_by = reviewer
        rec.rejection_reason = reason

        logger.info(
            "recommendation_rejected",
            rec_id=recommendation_id,
            reviewer=reviewer,
            reason=reason,
        )
        return rec

    def get_recommendation(self, recommendation_id: str) -> LearningRecommendation | None:
        """Get a recommendation by ID."""
        return self._recommendations.get(recommendation_id)

    def list_recommendations(
        self,
        status: RecommendationStatus | None = None,
        recommendation_type: RecommendationType | None = None,
    ) -> list[LearningRecommendation]:
        """List recommendations with optional filtering."""
        recs = list(self._recommendations.values())
        if status is not None:
            recs = [r for r in recs if r.status == status]
        if recommendation_type is not None:
            recs = [r for r in recs if r.recommendation_type == recommendation_type]
        return sorted(recs, key=lambda r: r.created_at, reverse=True)

    def list_auto_applied(self) -> list[AutoApplyResult]:
        """Return history of auto-applied changes."""
        return list(self._auto_applied)

    def _apply_recommendation(self, rec: LearningRecommendation) -> AutoApplyResult:
        """Apply a recommendation's changes."""
        try:
            if rec.recommendation_type == RecommendationType.THRESHOLD_ADJUSTMENT:
                return self._apply_threshold_adjustment(rec)
            elif rec.recommendation_type == RecommendationType.PLAYBOOK_UPDATE:
                return self._apply_playbook_update(rec)
            elif rec.recommendation_type == RecommendationType.ALERT_TUNING:
                return self._apply_alert_tuning(rec)
            elif rec.recommendation_type == RecommendationType.NEW_PLAYBOOK:
                return self._apply_new_playbook(rec)
            else:
                return AutoApplyResult(
                    recommendation_id=rec.id,
                    success=False,
                    error=f"Unknown recommendation type: {rec.recommendation_type}",
                )
        except Exception as e:
            logger.error(
                "recommendation_apply_failed",
                rec_id=rec.id,
                error=str(e),
            )
            return AutoApplyResult(
                recommendation_id=rec.id,
                success=False,
                error=str(e),
            )

    def _apply_threshold_adjustment(self, rec: LearningRecommendation) -> AutoApplyResult:
        """Apply a threshold adjustment (e.g., confidence threshold, alert sensitivity)."""
        changes = rec.changes
        applied: dict[str, Any] = {}

        for key, value in changes.items():
            applied[key] = {"old": None, "new": value}

        result = AutoApplyResult(
            recommendation_id=rec.id,
            success=True,
            applied_changes=applied,
        )
        self._auto_applied.append(result)

        logger.info(
            "threshold_adjustment_applied",
            rec_id=rec.id,
            changes=len(applied),
        )
        return result

    def _apply_playbook_update(self, rec: LearningRecommendation) -> AutoApplyResult:
        """Apply updates to an existing playbook."""
        if not rec.target_playbook:
            return AutoApplyResult(
                recommendation_id=rec.id,
                success=False,
                error="No target playbook specified",
            )

        if self._loader:
            playbook = self._loader.get(rec.target_playbook)
            if playbook is None:
                return AutoApplyResult(
                    recommendation_id=rec.id,
                    success=False,
                    error=f"Playbook not found: {rec.target_playbook}",
                )

        applied = {"playbook": rec.target_playbook, "updates": rec.changes}
        result = AutoApplyResult(
            recommendation_id=rec.id,
            success=True,
            applied_changes=applied,
        )
        self._auto_applied.append(result)

        logger.info(
            "playbook_update_applied",
            rec_id=rec.id,
            playbook=rec.target_playbook,
        )
        return result

    def _apply_alert_tuning(self, rec: LearningRecommendation) -> AutoApplyResult:
        """Apply alert tuning changes."""
        applied = {"alert_config": rec.changes}
        result = AutoApplyResult(
            recommendation_id=rec.id,
            success=True,
            applied_changes=applied,
        )
        self._auto_applied.append(result)

        logger.info("alert_tuning_applied", rec_id=rec.id)
        return result

    def _apply_new_playbook(self, rec: LearningRecommendation) -> AutoApplyResult:
        """Create a new playbook from a recommendation."""
        if not rec.changes.get("playbook_content"):
            return AutoApplyResult(
                recommendation_id=rec.id,
                success=False,
                error="No playbook content provided",
            )

        applied = {"new_playbook": rec.changes}
        result = AutoApplyResult(
            recommendation_id=rec.id,
            success=True,
            applied_changes=applied,
        )
        self._auto_applied.append(result)

        logger.info("new_playbook_created", rec_id=rec.id)
        return result
