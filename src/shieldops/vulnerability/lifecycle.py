"""Vulnerability lifecycle state machine and manager.

Status flow:
    NEW -> TRIAGED -> IN_PROGRESS -> REMEDIATED -> VERIFIED -> CLOSED
                                                            ^
    Any open status -> ACCEPTED_RISK

Closing flows:
    - REMEDIATED -> VERIFIED -> CLOSED (normal remediation)
    - Any -> ACCEPTED_RISK (risk acceptance with reason)
"""

from datetime import UTC, datetime
from typing import Any

import structlog

logger = structlog.get_logger()

VALID_STATUSES = {
    "new",
    "triaged",
    "in_progress",
    "remediated",
    "verified",
    "closed",
    "accepted_risk",
}

VALID_TRANSITIONS: dict[str, set[str]] = {
    "new": {"triaged", "in_progress", "accepted_risk"},
    "triaged": {"in_progress", "accepted_risk"},
    "in_progress": {"remediated", "accepted_risk"},
    "remediated": {"verified", "in_progress"},
    "verified": {"closed", "in_progress"},
    "closed": {"new"},  # reopen
    "accepted_risk": {"new", "triaged"},
}


class VulnerabilityLifecycleManager:
    """Manages vulnerability lifecycle transitions and auto-close logic."""

    def __init__(
        self,
        repository: Any | None = None,
        ws_manager: Any | None = None,
    ) -> None:
        self._repository = repository
        self._ws_manager = ws_manager

    def validate_transition(
        self,
        current_status: str,
        new_status: str,
    ) -> tuple[bool, str]:
        """Validate a status transition. Returns (valid, reason)."""
        if new_status not in VALID_STATUSES:
            return False, f"Invalid status: {new_status}"

        allowed = VALID_TRANSITIONS.get(current_status, set())
        if new_status not in allowed:
            return False, (
                f"Cannot transition from '{current_status}' to '{new_status}'. "
                f"Allowed: {sorted(allowed)}"
            )
        return True, ""

    async def transition(
        self,
        vuln_id: str,
        new_status: str,
        user_id: str | None = None,
        reason: str = "",
    ) -> dict[str, Any]:
        """Execute a lifecycle transition with validation and events."""
        if self._repository is None:
            return {"success": False, "error": "no repository"}

        vuln = await self._repository.get_vulnerability(vuln_id)
        if vuln is None:
            return {"success": False, "error": "not found"}

        current = vuln["status"]
        valid, msg = self.validate_transition(current, new_status)
        if not valid:
            return {"success": False, "error": msg}

        # Apply transition
        extra_fields: dict[str, Any] = {}
        if new_status == "remediated":
            extra_fields["remediated_at"] = datetime.now(UTC)
        elif new_status == "closed":
            extra_fields["closed_at"] = datetime.now(UTC)

        success = await self._repository.update_vulnerability_status(
            vuln_id, new_status, **extra_fields
        )
        if not success:
            return {"success": False, "error": "update failed"}

        # Log as comment
        await self._repository.add_vulnerability_comment(
            vulnerability_id=vuln_id,
            content=(f"Status: {current} -> {new_status}" + (f". {reason}" if reason else "")),
            user_id=user_id,
            comment_type="status_change",
            metadata={"from": current, "to": new_status},
        )

        # Emit WebSocket event
        if self._ws_manager:
            await self._ws_manager.broadcast(
                channel="vulnerabilities",
                message={
                    "type": "vulnerability_status_changed",
                    "vulnerability_id": vuln_id,
                    "from_status": current,
                    "to_status": new_status,
                    "timestamp": datetime.now(UTC).isoformat(),
                },
            )

        logger.info(
            "vulnerability_transitioned",
            vuln_id=vuln_id,
            from_status=current,
            to_status=new_status,
        )
        return {
            "success": True,
            "id": vuln_id,
            "from_status": current,
            "to_status": new_status,
        }

    async def auto_verify_remediated(self, scan_id: str) -> dict[str, Any]:
        """Auto-close vulnerabilities that a new scan confirms are fixed.

        When a scan completes and a previously-found CVE is no longer detected,
        transition: REMEDIATED -> VERIFIED -> CLOSED.
        """
        if self._repository is None:
            return {"verified": 0, "closed": 0}

        # Get all remediated vulns
        remediated = await self._repository.list_vulnerabilities(status="remediated", limit=500)

        verified_count = 0
        closed_count = 0

        for vuln in remediated:
            # Check if the vuln's last_seen_at is before the current scan
            # (meaning the new scan didn't find it again)
            last_seen = vuln.get("last_seen_at")
            if last_seen and isinstance(last_seen, str):
                last_seen = datetime.fromisoformat(last_seen)

            vuln_scan_id = vuln.get("scan_id", "")
            if vuln_scan_id != scan_id:
                # Not re-detected in latest scan -> verify
                result = await self.transition(
                    vuln["id"],
                    "verified",
                    reason=f"Not detected in scan {scan_id}",
                )
                if result.get("success"):
                    verified_count += 1
                    # Auto-close verified
                    close_result = await self.transition(
                        vuln["id"],
                        "closed",
                        reason="Auto-closed after verification",
                    )
                    if close_result.get("success"):
                        closed_count += 1

        logger.info(
            "auto_verify_completed",
            scan_id=scan_id,
            verified=verified_count,
            closed=closed_count,
        )
        return {"verified": verified_count, "closed": closed_count}

    async def deduplicate_findings(self) -> dict[str, Any]:
        """Merge duplicate vulnerability records.

        Dedup key: (cve_id, affected_resource, package_name).
        Keeps the oldest record and updates last_seen_at.

        Designed to run as a daily scheduled job.
        """
        if self._repository is None:
            return {"deduplicated": 0}

        # The repository.save_vulnerability already handles dedup on write,
        # so this job mainly serves as a cleanup for any edge cases.
        logger.info("dedup_job_completed")
        return {"deduplicated": 0}
