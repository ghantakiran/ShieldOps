"""Dependency-CVE mapping with transitive impact analysis.

Maps service dependencies to known CVEs and performs transitive impact
analysis to identify which services are affected by vulnerabilities in
direct and indirect dependencies.
"""

from __future__ import annotations

import enum
import time
import uuid
from collections import defaultdict
from typing import Any

import structlog
from pydantic import BaseModel, Field

logger = structlog.get_logger()


# -- Enums --------------------------------------------------------------------


class ImpactLevel(enum.StrEnum):
    NONE = "none"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class DependencyDepth(enum.StrEnum):
    DIRECT = "direct"
    TRANSITIVE = "transitive"
    RUNTIME_ONLY = "runtime_only"


# -- Models --------------------------------------------------------------------


class DependencyNode(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    service: str
    package_name: str
    version: str = ""
    depth: DependencyDepth = DependencyDepth.DIRECT
    parent_id: str = ""
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: float = Field(default_factory=time.time)


class VulnerabilityMapping(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    cve_id: str
    package_name: str
    affected_versions: list[str] = Field(default_factory=list)
    impact_level: ImpactLevel = ImpactLevel.MEDIUM
    description: str = ""
    created_at: float = Field(default_factory=time.time)


class ImpactAssessment(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    cve_id: str
    affected_services: list[str] = Field(default_factory=list)
    impact_level: ImpactLevel
    total_affected: int = 0
    transitive_affected: int = 0
    recommendation: str = ""
    assessed_at: float = Field(default_factory=time.time)


# -- Mapper --------------------------------------------------------------------


class DependencyVulnerabilityMapper:
    """Map service dependencies to CVEs and assess transitive impact.

    Parameters
    ----------
    max_services:
        Maximum number of unique services to track.
    max_depth:
        Maximum allowed dependency tree depth.
    """

    def __init__(
        self,
        max_services: int = 1000,
        max_depth: int = 10,
    ) -> None:
        self._nodes: dict[str, DependencyNode] = {}
        self._mappings: dict[str, VulnerabilityMapping] = {}
        self._assessments: dict[str, ImpactAssessment] = {}
        self._max_services = max_services
        self._max_depth = max_depth

    def register_service_dependencies(
        self,
        service: str,
        dependencies: list[dict[str, Any]],
    ) -> list[DependencyNode]:
        existing_services = {n.service for n in self._nodes.values()}
        if service not in existing_services and len(existing_services) >= self._max_services:
            raise ValueError(f"Maximum services limit reached: {self._max_services}")

        nodes: list[DependencyNode] = []
        for dep in dependencies:
            node = DependencyNode(
                service=service,
                package_name=dep.get("package_name", ""),
                version=dep.get("version", ""),
                depth=DependencyDepth(dep.get("depth", "direct")),
                parent_id=dep.get("parent_id", ""),
            )
            self._nodes[node.id] = node
            nodes.append(node)

        logger.info(
            "service_dependencies_registered",
            service=service,
            dependency_count=len(nodes),
        )
        return nodes

    def map_cve_impact(
        self,
        cve_id: str,
        package_name: str,
        affected_versions: list[str],
        impact_level: ImpactLevel = ImpactLevel.MEDIUM,
        description: str = "",
    ) -> VulnerabilityMapping:
        mapping = VulnerabilityMapping(
            cve_id=cve_id,
            package_name=package_name,
            affected_versions=affected_versions,
            impact_level=impact_level,
            description=description,
        )
        self._mappings[mapping.id] = mapping
        logger.info(
            "cve_mapping_created",
            mapping_id=mapping.id,
            cve_id=cve_id,
            package_name=package_name,
        )
        return mapping

    def get_affected_services(self, cve_id: str) -> list[str]:
        # Find all mappings for this CVE
        affected_packages: set[str] = set()
        for mapping in self._mappings.values():
            if mapping.cve_id == cve_id:
                affected_packages.add(mapping.package_name)

        if not affected_packages:
            return []

        # Find all services that depend on affected packages
        services: set[str] = set()
        for node in self._nodes.values():
            if node.package_name in affected_packages:
                services.add(node.service)

        return sorted(services)

    def get_service_vulnerabilities(self, service: str) -> list[VulnerabilityMapping]:
        # Find all packages this service depends on
        packages: set[str] = set()
        for node in self._nodes.values():
            if node.service == service:
                packages.add(node.package_name)

        if not packages:
            return []

        # Find all vulnerability mappings for those packages
        vulns: list[VulnerabilityMapping] = []
        for mapping in self._mappings.values():
            if mapping.package_name in packages:
                vulns.append(mapping)

        return vulns

    def build_dependency_tree(self, service: str) -> dict[str, Any]:
        service_nodes = [n for n in self._nodes.values() if n.service == service]

        # Build parent-child relationships
        children_map: dict[str, list[DependencyNode]] = defaultdict(list)
        roots: list[DependencyNode] = []

        for node in service_nodes:
            if node.parent_id:
                children_map[node.parent_id].append(node)
            else:
                roots.append(node)

        def _build_subtree(node: DependencyNode, current_depth: int) -> dict[str, Any]:
            subtree: dict[str, Any] = {
                "id": node.id,
                "package_name": node.package_name,
                "version": node.version,
                "depth": node.depth,
                "children": [],
            }
            if current_depth < self._max_depth:
                for child in children_map.get(node.id, []):
                    subtree["children"].append(_build_subtree(child, current_depth + 1))
            return subtree

        tree: dict[str, Any] = {
            "service": service,
            "total_dependencies": len(service_nodes),
            "dependencies": [_build_subtree(r, 1) for r in roots],
        }
        return tree

    def list_mappings(self) -> list[VulnerabilityMapping]:
        return list(self._mappings.values())

    def get_assessment(self, assessment_id: str) -> ImpactAssessment | None:
        return self._assessments.get(assessment_id)

    def get_stats(self) -> dict[str, Any]:
        services = {n.service for n in self._nodes.values()}
        packages = {n.package_name for n in self._nodes.values()}
        cves = {m.cve_id for m in self._mappings.values()}
        direct_deps = sum(1 for n in self._nodes.values() if n.depth == DependencyDepth.DIRECT)
        transitive_deps = sum(
            1 for n in self._nodes.values() if n.depth == DependencyDepth.TRANSITIVE
        )
        return {
            "total_nodes": len(self._nodes),
            "total_mappings": len(self._mappings),
            "total_assessments": len(self._assessments),
            "unique_services": len(services),
            "unique_packages": len(packages),
            "unique_cves": len(cves),
            "direct_dependencies": direct_deps,
            "transitive_dependencies": transitive_deps,
        }
