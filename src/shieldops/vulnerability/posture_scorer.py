"""Security Posture Scorer â€” calculates and tracks overall security posture scores."""

from __future__ import annotations

import time
import uuid
from enum import StrEnum
from typing import Any

import structlog
from pydantic import BaseModel, Field

logger = structlog.get_logger()


# ---------------------------------------------------------------------------
# Enums
# ---------------------------------------------------------------------------


class PostureCategory(StrEnum):
    VULNERABILITY_MANAGEMENT = "vulnerability_management"
    ACCESS_CONTROL = "access_control"
    ENCRYPTION = "encryption"
    NETWORK_SECURITY = "network_security"
    COMPLIANCE = "compliance"
    INCIDENT_RESPONSE = "incident_response"


class PostureGrade(StrEnum):
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    F = "F"


# ---------------------------------------------------------------------------
# Models
# ---------------------------------------------------------------------------


class PostureCheck(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    service: str
    category: PostureCategory
    check_name: str
    passed: bool = Field(default=True)
    weight: float = Field(default=1.0)
    details: str = Field(default="")
    checked_at: float = Field(default_factory=time.time)


class PostureScore(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    service: str
    overall_score: float = Field(default=0.0)
    grade: PostureGrade = Field(default=PostureGrade.F)
    category_scores: dict[str, Any] = Field(default_factory=dict)
    checks_passed: int = Field(default=0)
    checks_total: int = Field(default=0)
    scored_at: float = Field(default_factory=time.time)


# ---------------------------------------------------------------------------
# Main class
# ---------------------------------------------------------------------------


class SecurityPostureScorer:
    """Calculates and tracks overall security posture scores for services/org."""

    def __init__(self, max_checks: int = 100000, max_scores: int = 10000) -> None:
        self.max_checks = max_checks
        self.max_scores = max_scores
        self._checks: list[PostureCheck] = []
        self._scores: list[PostureScore] = []
        logger.info(
            "security_posture_scorer.initialized",
            max_checks=max_checks,
            max_scores=max_scores,
        )

    # -- helpers -------------------------------------------------------------

    @staticmethod
    def _grade_for_score(score: float) -> PostureGrade:
        if score >= 90:
            return PostureGrade.A
        if score >= 80:
            return PostureGrade.B
        if score >= 70:
            return PostureGrade.C
        if score >= 60:
            return PostureGrade.D
        return PostureGrade.F

    # -- public API ----------------------------------------------------------

    def record_check(
        self,
        service: str,
        category: PostureCategory,
        check_name: str,
        passed: bool,
        **kw: Any,
    ) -> PostureCheck:
        """Record a posture check result."""
        check = PostureCheck(
            service=service,
            category=category,
            check_name=check_name,
            passed=passed,
            **kw,
        )
        self._checks.append(check)
        if len(self._checks) > self.max_checks:
            self._checks = self._checks[-self.max_checks :]
        logger.info(
            "posture_scorer.check_recorded",
            check_id=check.id,
            service=service,
            category=category,
            passed=passed,
        )
        return check

    def calculate_score(self, service: str) -> PostureScore:
        """Compute weighted posture score from all checks for a service."""
        service_checks = [c for c in self._checks if c.service == service]

        # Compute per-category weighted pass percentage
        category_scores: dict[str, float] = {}
        category_weights: dict[str, float] = {}

        for cat in PostureCategory:
            cat_checks = [c for c in service_checks if c.category == cat]
            if not cat_checks:
                continue
            total_weight = sum(c.weight for c in cat_checks)
            if total_weight == 0:
                continue
            passed_weight = sum(c.weight for c in cat_checks if c.passed)
            cat_score = (passed_weight / total_weight) * 100
            category_scores[cat.value] = round(cat_score, 2)
            category_weights[cat.value] = total_weight

        # Overall = weighted average across categories
        if category_weights:
            total_w = sum(category_weights.values())
            overall = (
                sum(category_scores[cat] * category_weights[cat] for cat in category_scores)
                / total_w
            )
        else:
            overall = 0.0

        checks_passed = sum(1 for c in service_checks if c.passed)
        checks_total = len(service_checks)

        score = PostureScore(
            service=service,
            overall_score=round(overall, 2),
            grade=self._grade_for_score(overall),
            category_scores=category_scores,
            checks_passed=checks_passed,
            checks_total=checks_total,
            scored_at=time.time(),
        )
        self._scores.append(score)
        if len(self._scores) > self.max_scores:
            self._scores = self._scores[-self.max_scores :]

        logger.info(
            "posture_scorer.score_calculated",
            score_id=score.id,
            service=service,
            overall_score=score.overall_score,
            grade=score.grade,
        )
        return score

    def get_score(self, service: str) -> PostureScore | None:
        """Return the latest posture score for a service."""
        for s in reversed(self._scores):
            if s.service == service:
                return s
        return None

    def list_scores(self, grade: PostureGrade | None = None) -> list[PostureScore]:
        """Return all latest scores, optionally filtered by grade."""
        # Collect latest score per service
        latest: dict[str, PostureScore] = {}
        for s in self._scores:
            latest[s.service] = s
        result = list(latest.values())
        if grade is not None:
            result = [s for s in result if s.grade == grade]
        return result

    def get_checks(
        self,
        service: str | None = None,
        category: PostureCategory | None = None,
        passed: bool | None = None,
    ) -> list[PostureCheck]:
        """Filter checks by service, category, and/or passed status."""
        result = self._checks
        if service is not None:
            result = [c for c in result if c.service == service]
        if category is not None:
            result = [c for c in result if c.category == category]
        if passed is not None:
            result = [c for c in result if c.passed == passed]
        return result

    def get_trend(self, service: str, limit: int = 10) -> list[PostureScore]:
        """Return historical scores for a service, newest first."""
        scores = [s for s in self._scores if s.service == service]
        scores.reverse()
        return scores[:limit]

    def compare_services(self, services: list[str]) -> dict[str, Any]:
        """Compare posture scores across services."""
        result: dict[str, dict[str, Any]] = {}
        for svc in services:
            score = self.get_score(svc)
            if score:
                result[svc] = {"score": score.overall_score, "grade": score.grade}
            else:
                result[svc] = {"score": 0.0, "grade": PostureGrade.F}
        return result

    def get_worst_categories(self, service: str) -> list[dict[str, Any]]:
        """Return categories sorted by score ascending (worst first)."""
        service_checks = [c for c in self._checks if c.service == service]
        categories: list[dict[str, Any]] = []
        for cat in PostureCategory:
            cat_checks = [c for c in service_checks if c.category == cat]
            if not cat_checks:
                continue
            total_weight = sum(c.weight for c in cat_checks)
            if total_weight == 0:
                continue
            passed_weight = sum(c.weight for c in cat_checks if c.passed)
            cat_score = (passed_weight / total_weight) * 100
            categories.append(
                {
                    "category": cat.value,
                    "score": round(cat_score, 2),
                    "checks_passed": sum(1 for c in cat_checks if c.passed),
                    "checks_total": len(cat_checks),
                }
            )
        categories.sort(key=lambda x: x["score"])
        return categories

    def get_stats(self) -> dict[str, Any]:
        """Return aggregate statistics."""
        latest_scores = self.list_scores()
        grade_dist: dict[str, int] = {}
        for s in latest_scores:
            grade_dist[s.grade] = grade_dist.get(s.grade, 0) + 1

        category_totals: dict[str, list[float]] = {}
        for s in latest_scores:
            for cat, val in s.category_scores.items():
                category_totals.setdefault(cat, []).append(val)
        category_avg: dict[str, float] = {
            cat: round(sum(vals) / len(vals), 2) for cat, vals in category_totals.items() if vals
        }

        avg_score = 0.0
        if latest_scores:
            avg_score = round(sum(s.overall_score for s in latest_scores) / len(latest_scores), 2)

        return {
            "total_checks": len(self._checks),
            "total_scores": len(self._scores),
            "services_scored": len(latest_scores),
            "avg_score": avg_score,
            "grade_distribution": grade_dist,
            "category_avg_scores": category_avg,
        }
