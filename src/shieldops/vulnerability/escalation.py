"""Time-based escalation engine for vulnerability SLA breaches."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import UTC, datetime, timedelta
from typing import Any

import structlog

logger = structlog.get_logger()


@dataclass
class EscalationRule:
    """Defines when and how to escalate."""

    name: str
    condition: str  # sla_breach, sla_breach_2x, critical_unpatched_48h
    delay_hours: float  # Hours after condition before escalating
    notify_role: str  # team_lead, eng_manager, ciso
    channel: str  # slack, pagerduty, email
    priority: str = "high"  # low, medium, high, critical


@dataclass
class EscalationChain:
    """Ordered chain of escalations for a team."""

    team_id: str
    rules: list[EscalationRule] = field(default_factory=list)


DEFAULT_ESCALATION_RULES: list[EscalationRule] = [
    EscalationRule(
        name="sla_breach_team_lead",
        condition="sla_breach",
        delay_hours=0,
        notify_role="team_lead",
        channel="slack",
        priority="high",
    ),
    EscalationRule(
        name="sla_breach_2x_manager",
        condition="sla_breach_2x",
        delay_hours=0,
        notify_role="eng_manager",
        channel="pagerduty",
        priority="critical",
    ),
    EscalationRule(
        name="critical_unpatched_ciso",
        condition="critical_unpatched_48h",
        delay_hours=0,
        notify_role="ciso",
        channel="email",
        priority="critical",
    ),
]


class EscalationEngine:
    """Manages time-based escalation for vulnerability SLA breaches.

    Escalation levels:
    1. SLA breach -> team lead notification (Slack)
    2. SLA breach >2x -> engineering manager (PagerDuty)
    3. Critical CVE unpatched >48h -> CISO escalation (email)

    Configurable chains per team.
    """

    def __init__(
        self,
        repository: Any,
        notification_dispatcher: Any | None = None,
    ) -> None:
        self._repository = repository
        self._dispatcher = notification_dispatcher
        self._chains: dict[str, EscalationChain] = {}

    def register_chain(self, chain: EscalationChain) -> None:
        """Register an escalation chain for a team."""
        self._chains[chain.team_id] = chain
        logger.info("escalation_chain_registered", team_id=chain.team_id, rules=len(chain.rules))

    def get_chain(self, team_id: str) -> EscalationChain:
        """Get escalation chain for team, falling back to defaults."""
        if team_id in self._chains:
            return self._chains[team_id]
        return EscalationChain(team_id=team_id, rules=DEFAULT_ESCALATION_RULES)

    async def check_and_escalate(self) -> dict[str, Any]:
        """Check all open vulnerabilities for escalation conditions.

        Returns summary of escalations triggered.
        """
        escalations_triggered: list[dict[str, Any]] = []

        try:
            # Get all SLA-breached vulnerabilities
            breached = await self._repository.list_vulnerabilities(sla_breached=True)

            for vuln in breached:
                team_id = getattr(vuln, "assigned_team_id", None) or "default"
                chain = self.get_chain(team_id)

                for rule in chain.rules:
                    if self._should_escalate(vuln, rule):
                        result = await self._trigger_escalation(vuln, rule, team_id)
                        if result:
                            escalations_triggered.append(result)

            # Check critical unpatched >48h
            critical_vulns = await self._repository.list_vulnerabilities(
                severity="critical",
                status="new",
            )
            for vuln in critical_vulns:
                first_seen = getattr(vuln, "first_seen_at", None)
                if first_seen and (datetime.now(UTC) - first_seen) > timedelta(hours=48):
                    team_id = getattr(vuln, "assigned_team_id", None) or "default"
                    chain = self.get_chain(team_id)
                    for rule in chain.rules:
                        if rule.condition == "critical_unpatched_48h":
                            result = await self._trigger_escalation(vuln, rule, team_id)
                            if result:
                                escalations_triggered.append(result)

        except Exception as e:
            logger.error("escalation_check_failed", error=str(e))

        logger.info(
            "escalation_check_completed",
            escalations=len(escalations_triggered),
        )
        return {
            "checked_at": datetime.now(UTC).isoformat(),
            "escalations_triggered": len(escalations_triggered),
            "details": escalations_triggered,
        }

    def _should_escalate(self, vuln: Any, rule: EscalationRule) -> bool:
        """Check if a vulnerability matches the escalation rule condition."""
        sla_due = getattr(vuln, "sla_due_at", None)
        if not sla_due:
            return False

        now = datetime.now(UTC)

        if rule.condition == "sla_breach":
            return bool(getattr(vuln, "sla_breached", False))

        if rule.condition == "sla_breach_2x":
            if not getattr(vuln, "sla_breached", False):
                return False
            # Check if breach is >2x the SLA duration
            first_seen = getattr(vuln, "first_seen_at", now)
            sla_duration = sla_due - first_seen
            time_overdue = now - sla_due
            return time_overdue > sla_duration

        if rule.condition == "critical_unpatched_48h":
            severity = getattr(vuln, "severity", "")
            first_seen = getattr(vuln, "first_seen_at", now)
            return severity == "critical" and (now - first_seen) > timedelta(hours=48)

        return False

    async def _trigger_escalation(
        self,
        vuln: Any,
        rule: EscalationRule,
        team_id: str,
    ) -> dict[str, Any] | None:
        """Send an escalation notification."""
        vuln_id = getattr(vuln, "id", "unknown")
        cve_id = getattr(vuln, "cve_id", "")
        severity = getattr(vuln, "severity", "")

        logger.info(
            "escalation_triggered",
            vuln_id=vuln_id,
            rule=rule.name,
            team_id=team_id,
            notify_role=rule.notify_role,
            channel=rule.channel,
        )

        message = (
            f"[ESCALATION] {rule.name}: Vulnerability {vuln_id}"
            f" ({cve_id}, {severity}) requires attention. "
            f"Escalated to {rule.notify_role} via {rule.channel}."
        )

        if self._dispatcher:
            try:
                await self._dispatcher.send_notification(
                    channel=rule.channel,
                    subject=f"Security Escalation: {cve_id or vuln_id}",
                    body=message,
                    metadata={
                        "type": "escalation",
                        "rule": rule.name,
                        "team_id": team_id,
                        "vuln_id": vuln_id,
                        "priority": rule.priority,
                    },
                )
            except Exception as e:
                logger.error(
                    "escalation_notification_failed",
                    vuln_id=vuln_id,
                    rule=rule.name,
                    error=str(e),
                )

        return {
            "vuln_id": vuln_id,
            "cve_id": cve_id,
            "severity": severity,
            "rule": rule.name,
            "notify_role": rule.notify_role,
            "channel": rule.channel,
            "team_id": team_id,
            "triggered_at": datetime.now(UTC).isoformat(),
        }
