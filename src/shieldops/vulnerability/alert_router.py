"""Alert routing engine for vulnerability notifications.

Routes vulnerability alerts to the appropriate teams based on:
- Resource ownership
- Vulnerability type
- Severity
- SLA breach status
"""

from typing import Any

import structlog

logger = structlog.get_logger()


class AlertRouter:
    """Routes vulnerability alerts to responsible teams."""

    def __init__(
        self,
        repository: Any | None = None,
        dispatcher: Any | None = None,
    ) -> None:
        self._repository = repository
        self._dispatcher = dispatcher

    async def route_new_vulnerability(
        self,
        vulnerability: dict[str, Any],
    ) -> dict[str, Any]:
        """Route a new vulnerability alert to the appropriate team."""
        severity = vulnerability.get("severity", "medium")
        affected_resource = vulnerability.get("affected_resource", "")
        scanner_type = vulnerability.get("scanner_type", "cve")

        # Determine the team based on resource ownership
        team = await self._find_owning_team(affected_resource, scanner_type)

        if team:
            # Auto-assign to team
            if self._repository:
                await self._repository.assign_vulnerability(vulnerability["id"], team_id=team["id"])

            # Send notification
            await self._notify_team(team, vulnerability)

        return {
            "routed": team is not None,
            "team_id": team["id"] if team else None,
            "team_name": team["name"] if team else None,
            "severity": severity,
        }

    async def route_sla_breach(
        self,
        vulnerability: dict[str, Any],
        breach_info: dict[str, Any],
    ) -> dict[str, Any]:
        """Escalate an SLA-breached vulnerability."""
        team_id = vulnerability.get("assigned_team_id")
        severity = vulnerability.get("severity", "medium")
        overdue_hours = breach_info.get("time_overdue_hours", 0)
        breach_multiplier = breach_info.get("breach_multiplier", 0)

        if not self._dispatcher:
            return {"escalated": False, "reason": "no dispatcher"}

        # Build escalation message
        title = f"SLA BREACH: {vulnerability.get('title', vulnerability.get('cve_id', 'Unknown'))}"
        description = (
            f"Vulnerability {vulnerability['id']} ({severity}) has breached its SLA.\n"
            f"Overdue by {overdue_hours:.1f} hours "
            f"({breach_multiplier:.1f}x SLA window).\n"
            f"Resource: {vulnerability.get('affected_resource', 'unknown')}"
        )

        # Escalation severity based on breach multiplier
        escalation_severity = severity
        if breach_multiplier > 2.0:
            escalation_severity = "critical"
        elif breach_multiplier > 1.0 and severity != "critical":
            escalation_severity = "high"

        # Send via dispatcher
        if team_id and self._repository:
            team = await self._repository.get_team(team_id)
            if team:
                # Try team's notification channels
                if team.get("slack_channel"):
                    await self._dispatcher.send(
                        "slack",
                        description,
                        severity=escalation_severity,
                        details={"channel": team["slack_channel"]},
                    )
                if team.get("pagerduty_service_id") and escalation_severity in (
                    "critical",
                    "high",
                ):
                    await self._dispatcher.send_escalation(
                        "pagerduty",
                        title,
                        description,
                        severity=escalation_severity,
                        source="shieldops-sla",
                    )

        # Always broadcast for critical breaches
        if escalation_severity == "critical":
            await self._dispatcher.broadcast(
                description,
                severity="critical",
                details={"vuln_id": vulnerability["id"]},
            )

        logger.warning(
            "sla_breach_escalated",
            vuln_id=vulnerability["id"],
            severity=severity,
            overdue_hours=overdue_hours,
            escalation_severity=escalation_severity,
        )

        return {
            "escalated": True,
            "escalation_severity": escalation_severity,
            "team_id": team_id,
        }

    async def _find_owning_team(
        self,
        affected_resource: str,
        scanner_type: str,
    ) -> dict[str, Any] | None:
        """Find the team that owns a resource."""
        if self._repository is None:
            return None

        teams = await self._repository.list_teams()
        if not teams:
            return None

        # Simple heuristic: match team name patterns against resource
        resource_lower = affected_resource.lower()
        for team in teams:
            team_name_lower = team["name"].lower()
            # Check if team name appears in the resource path
            if team_name_lower in resource_lower:
                return team

        # Fallback: route by scanner type
        scanner_team_map = {
            "secret": "security",
            "iac": "platform",
            "network": "infrastructure",
            "k8s_security": "platform",
            "container": "platform",
        }
        target_team = scanner_team_map.get(scanner_type, "")
        for team in teams:
            if target_team and target_team in team["name"].lower():
                return team

        # Default to first team if exists
        return teams[0] if teams else None

    async def _notify_team(
        self,
        team: dict[str, Any],
        vulnerability: dict[str, Any],
    ) -> None:
        """Send notification to a team about a new vulnerability."""
        if not self._dispatcher:
            return

        severity = vulnerability.get("severity", "medium")
        message = (
            f"New {severity} vulnerability assigned to {team['name']}: "
            f"{vulnerability.get('title', vulnerability.get('cve_id', 'Unknown'))}\n"
            f"Resource: {vulnerability.get('affected_resource', 'unknown')}\n"
            f"Scanner: {vulnerability.get('scanner_type', 'unknown')}"
        )

        if team.get("slack_channel"):
            await self._dispatcher.send(
                "slack",
                message,
                severity=severity,
                details={"channel": team["slack_channel"]},
            )

        if severity in ("critical", "high") and team.get("pagerduty_service_id"):
            await self._dispatcher.send_escalation(
                "pagerduty",
                f"New {severity} vulnerability",
                message,
                severity=severity,
                source="shieldops-vuln",
            )
