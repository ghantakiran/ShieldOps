"""Security newsletter service for periodic vulnerability digests."""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from typing import Any

import structlog
from jinja2 import Environment, PackageLoader, select_autoescape

logger = structlog.get_logger()


class NewsletterConfig:
    """Configuration for newsletter generation."""

    def __init__(
        self,
        frequency: str = "weekly",  # daily, weekly
        include_new_vulns: bool = True,
        include_sla_breaches: bool = True,
        include_remediation_progress: bool = True,
        include_posture_trend: bool = True,
        include_top_risks: bool = True,
        include_industry_alerts: bool = True,
        max_vulnerabilities: int = 50,
        team_id: str | None = None,  # None = all teams
    ) -> None:
        self.frequency = frequency
        self.include_new_vulns = include_new_vulns
        self.include_sla_breaches = include_sla_breaches
        self.include_remediation_progress = include_remediation_progress
        self.include_posture_trend = include_posture_trend
        self.include_top_risks = include_top_risks
        self.include_industry_alerts = include_industry_alerts
        self.max_vulnerabilities = max_vulnerabilities
        self.team_id = team_id


class NewsletterSection:
    """A section of the newsletter."""

    def __init__(
        self,
        title: str,
        content: dict[str, Any],
        priority: int = 0,
    ) -> None:
        self.title = title
        self.content = content
        self.priority = priority


class SecurityNewsletterService:
    """Generates daily/weekly security digests.

    Sections:
    - New vulnerabilities discovered since last digest
    - SLA breaches and approaching deadlines
    - Remediation progress (closed/verified counts)
    - Security posture trend (score changes)
    - Top risks requiring attention
    - Industry CVE alerts (critical CVEs from NVD)
    """

    def __init__(
        self,
        repository: Any,
        notification_dispatcher: Any | None = None,
    ) -> None:
        self._repository = repository
        self._dispatcher = notification_dispatcher
        self._jinja_env = Environment(
            loader=PackageLoader("shieldops.vulnerability", "templates"),
            autoescape=select_autoescape(["html"]),
        )

    async def generate_daily_digest(
        self,
        config: NewsletterConfig | None = None,
    ) -> dict[str, Any]:
        """Generate a daily security digest."""
        config = config or NewsletterConfig(frequency="daily")
        since = datetime.now(UTC) - timedelta(days=1)
        return await self._generate_digest(config, since, "daily")

    async def generate_weekly_digest(
        self,
        config: NewsletterConfig | None = None,
    ) -> dict[str, Any]:
        """Generate a weekly security summary."""
        config = config or NewsletterConfig(frequency="weekly")
        since = datetime.now(UTC) - timedelta(weeks=1)
        return await self._generate_digest(config, since, "weekly")

    async def _generate_digest(
        self,
        config: NewsletterConfig,
        since: datetime,
        frequency: str,
    ) -> dict[str, Any]:
        """Core digest generation logic."""
        sections: list[NewsletterSection] = []

        # New vulnerabilities
        if config.include_new_vulns:
            new_vulns = await self._get_new_vulnerabilities(since, config)
            if new_vulns:
                sections.append(
                    NewsletterSection(
                        title="New Vulnerabilities",
                        content=new_vulns,
                        priority=1,
                    )
                )

        # SLA breaches
        if config.include_sla_breaches:
            sla_data = await self._get_sla_breaches(config)
            if sla_data.get("breached") or sla_data.get("approaching"):
                sections.append(
                    NewsletterSection(
                        title="SLA Status",
                        content=sla_data,
                        priority=0,
                    )
                )

        # Remediation progress
        if config.include_remediation_progress:
            progress = await self._get_remediation_progress(since, config)
            sections.append(
                NewsletterSection(
                    title="Remediation Progress",
                    content=progress,
                    priority=2,
                )
            )

        # Posture trend
        if config.include_posture_trend:
            trend = await self._get_posture_trend(since)
            sections.append(
                NewsletterSection(
                    title="Security Posture",
                    content=trend,
                    priority=3,
                )
            )

        # Top risks
        if config.include_top_risks:
            risks = await self._get_top_risks(config)
            if risks:
                sections.append(
                    NewsletterSection(
                        title="Top Risks",
                        content={"risks": risks},
                        priority=4,
                    )
                )

        # Sort by priority
        sections.sort(key=lambda s: s.priority)

        # Render
        digest = {
            "frequency": frequency,
            "generated_at": datetime.now(UTC).isoformat(),
            "period_start": since.isoformat(),
            "period_end": datetime.now(UTC).isoformat(),
            "sections": [{"title": s.title, "content": s.content} for s in sections],
            "team_id": config.team_id,
        }

        # Render HTML and plain text
        digest["html"] = self._render_html(digest, frequency)
        digest["plain_text"] = self._render_plain_text(digest)

        return digest

    async def send_digest(
        self,
        digest: dict[str, Any],
        recipients: list[str] | None = None,
        team_id: str | None = None,
    ) -> dict[str, Any]:
        """Send a generated digest via notification dispatcher."""
        if not self._dispatcher:
            logger.warning("newsletter_send_skipped", reason="no dispatcher")
            return {"sent": False, "reason": "no dispatcher configured"}

        # Resolve recipients from team if needed
        if not recipients and team_id and self._repository:
            try:
                team = await self._repository.get_team(team_id)
                if team and hasattr(team, "members"):
                    recipients = [m.email for m in team.members if hasattr(m, "email")]
            except Exception:
                pass

        if not recipients:
            return {"sent": False, "reason": "no recipients"}

        try:
            await self._dispatcher.send_notification(
                channel="email",
                subject=(f"Security Digest â€” {digest.get('frequency', 'weekly').title()}"),
                body=digest.get("html", digest.get("plain_text", "")),
                recipients=recipients,
                metadata={
                    "type": "security_newsletter",
                    "frequency": digest["frequency"],
                },
            )
            logger.info(
                "newsletter_sent",
                frequency=digest["frequency"],
                recipient_count=len(recipients),
            )
            return {"sent": True, "recipients": len(recipients)}
        except Exception as e:
            logger.error("newsletter_send_failed", error=str(e))
            return {"sent": False, "error": str(e)}

    async def preview(
        self,
        frequency: str = "weekly",
        config: NewsletterConfig | None = None,
    ) -> dict[str, Any]:
        """Preview the next newsletter without sending."""
        if frequency == "daily":
            return await self.generate_daily_digest(config)
        return await self.generate_weekly_digest(config)

    # -- Data gathering helpers -------------------------------------------

    async def _get_new_vulnerabilities(
        self,
        since: datetime,
        config: NewsletterConfig,
    ) -> dict[str, Any]:
        """Get new vulnerabilities since the given timestamp."""
        try:
            vulns = await self._repository.list_vulnerabilities(
                created_after=since,
                team_id=config.team_id,
                limit=config.max_vulnerabilities,
            )
            # Group by severity
            by_severity: dict[str, int] = {}
            for v in vulns:
                sev = getattr(v, "severity", "unknown")
                by_severity[sev] = by_severity.get(sev, 0) + 1

            return {
                "total": len(vulns),
                "by_severity": by_severity,
                "vulnerabilities": [
                    {
                        "id": getattr(v, "id", ""),
                        "cve_id": getattr(v, "cve_id", ""),
                        "severity": getattr(v, "severity", ""),
                        "title": getattr(v, "description", "")[:120],
                        "affected_resource": getattr(v, "affected_resource", ""),
                        "status": getattr(v, "status", ""),
                    }
                    for v in vulns[:20]  # Top 20 for newsletter
                ],
            }
        except Exception as e:
            logger.warning("newsletter_vulns_failed", error=str(e))
            return {"total": 0, "by_severity": {}, "vulnerabilities": []}

    async def _get_sla_breaches(
        self,
        config: NewsletterConfig,
    ) -> dict[str, Any]:
        """Get SLA breach status."""
        try:
            breached = await self._repository.list_vulnerabilities(
                sla_breached=True,
                team_id=config.team_id,
            )
            return {
                "breached": len(breached),
                "breached_vulns": [
                    {
                        "id": getattr(v, "id", ""),
                        "cve_id": getattr(v, "cve_id", ""),
                        "severity": getattr(v, "severity", ""),
                        "sla_due_at": str(getattr(v, "sla_due_at", "")),
                    }
                    for v in breached[:10]
                ],
            }
        except Exception as e:
            logger.warning("newsletter_sla_failed", error=str(e))
            return {"breached": 0, "breached_vulns": []}

    async def _get_remediation_progress(
        self,
        since: datetime,
        config: NewsletterConfig,
    ) -> dict[str, Any]:
        """Get remediation progress stats."""
        try:
            stats = await self._repository.get_vulnerability_stats(
                team_id=config.team_id,
            )
            return {
                "total_open": stats.get("total_open", 0),
                "remediated": stats.get("remediated", 0),
                "verified": stats.get("verified", 0),
                "closed": stats.get("closed", 0),
                "accepted_risk": stats.get("accepted_risk", 0),
                "mttr_hours": stats.get("mttr_hours"),
            }
        except Exception as e:
            logger.warning("newsletter_progress_failed", error=str(e))
            return {
                "total_open": 0,
                "remediated": 0,
                "verified": 0,
                "closed": 0,
            }

    async def _get_posture_trend(
        self,
        since: datetime,
    ) -> dict[str, Any]:
        """Get security posture trend data."""
        try:
            scans = await self._repository.list_security_scans(
                since=since,
                limit=10,
            )
            scores = []
            for s in scans:
                if hasattr(s, "posture_score") and s.posture_score is not None:
                    scores.append(s.posture_score)

            current = scores[-1] if scores else None
            previous = scores[0] if len(scores) > 1 else None
            delta = (current - previous) if current and previous else None

            return {
                "current_score": current,
                "previous_score": previous,
                "delta": delta,
                "trend": (
                    "improving"
                    if delta and delta > 0
                    else ("declining" if delta and delta < 0 else "stable")
                ),
                "scan_count": len(scans),
            }
        except Exception as e:
            logger.warning("newsletter_posture_failed", error=str(e))
            return {"current_score": None, "trend": "unknown"}

    async def _get_top_risks(
        self,
        config: NewsletterConfig,
    ) -> list[dict[str, Any]]:
        """Get top risks needing attention."""
        try:
            critical = await self._repository.list_vulnerabilities(
                severity="critical",
                status="new",
                team_id=config.team_id,
                limit=5,
            )
            return [
                {
                    "id": getattr(v, "id", ""),
                    "cve_id": getattr(v, "cve_id", ""),
                    "severity": getattr(v, "severity", ""),
                    "description": getattr(v, "description", "")[:200],
                    "affected_resource": getattr(v, "affected_resource", ""),
                    "days_open": (
                        datetime.now(UTC) - getattr(v, "first_seen_at", datetime.now(UTC))
                    ).days,
                }
                for v in critical
            ]
        except Exception as e:
            logger.warning("newsletter_risks_failed", error=str(e))
            return []

    # -- Rendering --------------------------------------------------------

    def _render_html(self, digest: dict[str, Any], frequency: str) -> str:
        """Render digest as HTML email."""
        try:
            template_name = f"newsletter_{frequency}.html"
            template = self._jinja_env.get_template(template_name)
            return template.render(digest=digest)
        except Exception as e:
            logger.warning("newsletter_html_render_failed", error=str(e))
            return self._render_fallback_html(digest)

    def _render_fallback_html(self, digest: dict[str, Any]) -> str:
        """Fallback HTML when template is missing."""
        sections_html = ""
        for section in digest.get("sections", []):
            sections_html += f"<h2>{section['title']}</h2>"
            sections_html += f"<pre>{section['content']}</pre>"

        return (
            "<html>"
            '<body style="font-family: sans-serif; max-width: 600px;'
            ' margin: 0 auto;">'
            "<h1>ShieldOps Security Digest</h1>"
            f"<p>Period: {digest.get('period_start', '')} to"
            f" {digest.get('period_end', '')}</p>"
            f"{sections_html}"
            '<hr><p style="color: #666;">Generated by ShieldOps Security'
            " Platform</p>"
            "</body></html>"
        )

    def _render_plain_text(self, digest: dict[str, Any]) -> str:
        """Render digest as plain text."""
        lines = [
            "ShieldOps Security Digest",
            "=" * 40,
            (f"Period: {digest.get('period_start', '')} to {digest.get('period_end', '')}"),
            "",
        ]
        for section in digest.get("sections", []):
            lines.append(f"## {section['title']}")
            lines.append("-" * 30)
            content = section.get("content", {})
            for key, value in content.items():
                if isinstance(value, list):
                    lines.append(f"  {key}: {len(value)} items")
                else:
                    lines.append(f"  {key}: {value}")
            lines.append("")

        lines.append("---")
        lines.append("Generated by ShieldOps Security Platform")
        return "\n".join(lines)
