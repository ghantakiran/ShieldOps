"""SLA enforcement engine for vulnerability management.

Default SLAs:
- Critical: 24 hours
- High: 72 hours (3 days)
- Medium: 7 days
- Low: 30 days
"""

from datetime import UTC, datetime, timedelta
from typing import Any

import structlog

logger = structlog.get_logger()

DEFAULT_SLAS: dict[str, timedelta] = {
    "critical": timedelta(hours=24),
    "high": timedelta(hours=72),
    "medium": timedelta(days=7),
    "low": timedelta(days=30),
}


class SLAEngine:
    """Manages SLA compliance for vulnerabilities."""

    def __init__(
        self,
        sla_overrides: dict[str, timedelta] | None = None,
        repository: Any | None = None,
    ) -> None:
        self._slas = {**DEFAULT_SLAS, **(sla_overrides or {})}
        self._repository = repository

    def calculate_sla_due_date(
        self,
        severity: str,
        created_at: datetime | None = None,
    ) -> datetime:
        """Calculate the SLA due date for a vulnerability."""
        base = created_at or datetime.now(UTC)
        delta = self._slas.get(severity, DEFAULT_SLAS["medium"])
        return base + delta

    def check_sla_compliance(
        self,
        vulnerability: dict[str, Any],
    ) -> dict[str, Any]:
        """Check if a vulnerability is within its SLA.

        Returns compliance status with breach details.
        """
        status = vulnerability.get("status", "new")
        # Closed/accepted vulnerabilities are always compliant
        if status in ("closed", "verified", "accepted_risk"):
            return {"compliant": True, "breached": False, "status": status}

        severity = vulnerability.get("severity", "medium")
        sla_due = vulnerability.get("sla_due_at")

        if sla_due is None:
            first_seen = vulnerability.get("first_seen_at")
            if first_seen and isinstance(first_seen, str):
                first_seen = datetime.fromisoformat(first_seen)
            if first_seen:
                sla_due = self.calculate_sla_due_date(severity, first_seen)
            else:
                return {"compliant": True, "breached": False, "reason": "no_sla_date"}

        if isinstance(sla_due, str):
            sla_due = datetime.fromisoformat(sla_due)

        now = datetime.now(UTC)
        breached = now > sla_due
        time_remaining = sla_due - now if not breached else timedelta(0)
        time_overdue = now - sla_due if breached else timedelta(0)

        return {
            "compliant": not breached,
            "breached": breached,
            "sla_due_at": sla_due.isoformat(),
            "severity": severity,
            "time_remaining_hours": max(0, time_remaining.total_seconds() / 3600),
            "time_overdue_hours": time_overdue.total_seconds() / 3600 if breached else 0,
            "breach_multiplier": (
                time_overdue / self._slas.get(severity, DEFAULT_SLAS["medium"]) if breached else 0.0
            ),
        }

    async def check_all_sla_compliance(self) -> dict[str, Any]:
        """Check SLA compliance for all open vulnerabilities.

        Designed to run as an hourly scheduled job.
        """
        if self._repository is None:
            return {"checked": 0, "breached": 0, "error": "no repository"}

        open_statuses = ["new", "triaged", "in_progress", "remediated"]
        total_checked = 0
        newly_breached = 0

        for status in open_statuses:
            vulns = await self._repository.list_vulnerabilities(status=status, limit=500)
            for vuln in vulns:
                total_checked += 1
                compliance = self.check_sla_compliance(vuln)

                if compliance["breached"] and not vuln.get("sla_breached"):
                    # Mark as breached in DB
                    await self._repository.update_vulnerability_status(
                        vuln["id"], vuln["status"], sla_breached=True
                    )
                    newly_breached += 1
                    logger.warning(
                        "sla_breached",
                        vuln_id=vuln["id"],
                        severity=vuln.get("severity"),
                        overdue_hours=compliance.get("time_overdue_hours"),
                    )

        logger.info(
            "sla_check_completed",
            total_checked=total_checked,
            newly_breached=newly_breached,
        )
        return {
            "checked": total_checked,
            "newly_breached": newly_breached,
        }
