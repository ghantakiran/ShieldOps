"""Matches vulnerability findings to remediation playbooks."""

from __future__ import annotations

from typing import Any

import structlog

logger = structlog.get_logger()


# Mapping of vulnerability patterns to playbook files
PLAYBOOK_MAPPING: dict[str, list[str]] = {
    # CVE severity-based
    "critical_cve": ["security/cve-critical-patch.yaml"],
    "high_cve": ["security/cve-critical-patch.yaml"],
    # Scanner type-based
    "secret_leak": ["security/secret-leak-response.yaml"],
    "iac_misconfiguration": ["security/iac-misconfig-fix.yaml"],
    "network_exposure": ["security/network-exposure-fix.yaml"],
    "k8s_rbac": ["security/k8s-rbac-remediation.yaml"],
    "k8s_pod_security": ["security/k8s-rbac-remediation.yaml"],
}


class PlaybookMatcher:
    """Matches vulnerability findings to appropriate remediation playbooks.

    Falls back to LLM-generated steps when no playbook matches.
    """

    def __init__(
        self,
        playbook_loader: Any | None = None,
    ) -> None:
        self._loader = playbook_loader
        self._custom_mappings: dict[str, list[str]] = {}

    def add_mapping(self, pattern: str, playbooks: list[str]) -> None:
        """Add a custom pattern-to-playbook mapping."""
        self._custom_mappings[pattern] = playbooks

    def match(self, vulnerability: dict[str, Any]) -> list[dict[str, Any]]:
        """Find matching playbooks for a vulnerability.

        Args:
            vulnerability: Dict with keys like severity, scanner_type,
                          cve_id, check_type, title, etc.

        Returns:
            List of matched playbook info dicts.
        """
        matches: list[dict[str, Any]] = []
        patterns = self._detect_patterns(vulnerability)

        for pattern in patterns:
            # Check custom mappings first
            if pattern in self._custom_mappings:
                for pb_path in self._custom_mappings[pattern]:
                    playbook = self._load_playbook(pb_path)
                    if playbook:
                        matches.append(playbook)

            # Then check default mappings
            if pattern in PLAYBOOK_MAPPING:
                for pb_path in PLAYBOOK_MAPPING[pattern]:
                    playbook = self._load_playbook(pb_path)
                    if playbook and playbook not in matches:
                        matches.append(playbook)

        if not matches:
            logger.debug(
                "no_playbook_match",
                vuln_id=vulnerability.get("id", ""),
                patterns=patterns,
            )

        return matches

    def get_remediation_steps(
        self,
        vulnerability: dict[str, Any],
    ) -> list[str]:
        """Get ordered remediation steps for a vulnerability.

        Returns steps from matched playbooks, or generic steps
        based on vulnerability type.
        """
        matches = self.match(vulnerability)

        if matches:
            steps: list[str] = []
            for playbook in matches:
                pb_steps = playbook.get("steps", [])
                for step in pb_steps:
                    if isinstance(step, dict):
                        desc = step.get("description", step.get("name", ""))
                        if desc and desc not in steps:
                            steps.append(desc)
                    elif isinstance(step, str) and step not in steps:
                        steps.append(step)
            return steps

        # Fallback: generic steps based on vulnerability type
        return self._generic_steps(vulnerability)

    def _detect_patterns(self, vulnerability: dict[str, Any]) -> list[str]:
        """Detect applicable patterns from vulnerability attributes."""
        patterns: list[str] = []
        severity = vulnerability.get("severity", "").lower()
        scanner_type = vulnerability.get("scanner_type", "").lower()
        check_type = vulnerability.get("check_type", "").lower()
        title = vulnerability.get("title", "").lower()

        # CVE severity patterns
        if severity == "critical" and vulnerability.get("cve_id"):
            patterns.append("critical_cve")
        elif severity == "high" and vulnerability.get("cve_id"):
            patterns.append("high_cve")

        # Scanner type patterns
        if scanner_type in ("git_secrets", "secret"):
            patterns.append("secret_leak")
        elif scanner_type in ("iac", "checkov"):
            patterns.append("iac_misconfiguration")
        elif scanner_type == "network":
            patterns.append("network_exposure")

        # K8s specific patterns
        if scanner_type == "k8s_security" or "kubernetes" in title:
            if "rbac" in check_type or "rbac" in title:
                patterns.append("k8s_rbac")
            elif "pod" in check_type or "privileged" in title:
                patterns.append("k8s_pod_security")
            else:
                patterns.append("k8s_rbac")  # Default K8s playbook

        return patterns

    def _load_playbook(self, path: str) -> dict[str, Any] | None:
        """Load a playbook by path using the playbook loader."""
        if not self._loader:
            return {"path": path, "name": path, "steps": []}

        try:
            playbook = self._loader.get(path)
            if playbook:
                return {
                    "path": path,
                    "name": getattr(playbook, "name", path),
                    "steps": getattr(playbook, "steps", []),
                    "description": getattr(playbook, "description", ""),
                }
        except Exception as e:
            logger.warning("playbook_load_failed", path=path, error=str(e))

        return None

    def _generic_steps(self, vulnerability: dict[str, Any]) -> list[str]:
        """Generate generic remediation steps when no playbook matches."""
        severity = vulnerability.get("severity", "medium").lower()
        scanner_type = vulnerability.get("scanner_type", "")

        steps = ["Assess the vulnerability impact and affected resources"]

        if vulnerability.get("cve_id"):
            steps.append(f"Check if a patch is available for {vulnerability['cve_id']}")
            steps.append("Test the patch in a staging environment")
            steps.append("Apply the patch with rollback plan ready")
        elif scanner_type == "secret":
            steps.append("Rotate the compromised credential immediately")
            steps.append("Audit access logs for unauthorized usage")
            steps.append("Move secret to a secrets manager (Vault, AWS SM)")
        elif scanner_type == "iac":
            steps.append("Review the misconfiguration details")
            steps.append("Update the IaC template to comply with policy")
            steps.append("Apply the fix via CI/CD pipeline")
        elif scanner_type == "network":
            steps.append("Review the exposed port/service")
            steps.append("Restrict access via security group / firewall rules")
            steps.append("Verify the fix doesn't break dependent services")
        else:
            steps.append("Investigate the finding and determine root cause")
            steps.append("Implement remediation appropriate to the finding")

        steps.append("Verify the fix resolves the vulnerability")

        if severity in ("critical", "high"):
            steps.append("Document the incident and remediation for audit")

        return steps
