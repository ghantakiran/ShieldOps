"""Attack surface mapping for security-focused infrastructure views.

Maps external services, exposed resources, IAM risks, unpatched services,
and certificate status into a unified attack surface model.
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import Any

import structlog
from pydantic import BaseModel, Field

logger = structlog.get_logger()


class AttackSurfaceEntry(BaseModel):
    """A single entry in the attack surface map."""

    resource_id: str
    resource_type: str
    category: str  # network, identity, application, data
    risk_level: str = "medium"
    exposure: str = "internal"  # external, internal, hybrid
    details: dict[str, Any] = Field(default_factory=dict)
    recommendations: list[str] = Field(default_factory=list)


class AttackSurfaceMap(BaseModel):
    """Complete attack surface map."""

    entries: list[AttackSurfaceEntry] = Field(default_factory=list)
    score_by_category: dict[str, float] = Field(default_factory=dict)
    overall_score: float = 0.0
    total_external: int = 0
    total_internal: int = 0
    timestamp: str = Field(default_factory=lambda: datetime.now(UTC).isoformat())


class AttackSurfaceMapper:
    """Maps the organization's attack surface across infrastructure.

    Aggregates data from connectors, vulnerability scans, and credential
    stores to build a comprehensive attack surface view.

    Args:
        connector_router: Infrastructure connector router.
        repository: Database repository for vulnerability data.
        credential_stores: List of credential store backends.
    """

    def __init__(
        self,
        connector_router: Any | None = None,
        repository: Any | None = None,
        credential_stores: list[Any] | None = None,
    ) -> None:
        self._router = connector_router
        self._repository = repository
        self._credential_stores = credential_stores or []

    async def map(self) -> AttackSurfaceMap:
        """Build the complete attack surface map."""
        entries: list[AttackSurfaceEntry] = []

        # Gather data from all sources
        entries.extend(await self._map_external_services())
        entries.extend(await self._map_exposed_resources())
        entries.extend(await self._map_iam_risks())
        entries.extend(await self._map_unpatched_services())
        entries.extend(await self._map_certificate_status())

        # Calculate scores by category
        categories = ["network", "identity", "application", "data"]
        score_by_category: dict[str, float] = {}
        for cat in categories:
            cat_entries = [e for e in entries if e.category == cat]
            score_by_category[cat] = self._calculate_category_score(cat_entries)

        overall = (
            sum(score_by_category.values()) / len(score_by_category) if score_by_category else 100.0
        )

        total_external = sum(1 for e in entries if e.exposure == "external")
        total_internal = sum(1 for e in entries if e.exposure == "internal")

        return AttackSurfaceMap(
            entries=entries,
            score_by_category=score_by_category,
            overall_score=round(overall, 1),
            total_external=total_external,
            total_internal=total_internal,
        )

    async def get_changes(self, since_hours: int = 24) -> dict[str, Any]:
        """Get attack surface changes since the given time window."""
        current = await self.map()
        return {
            "current_entry_count": len(current.entries),
            "external_count": current.total_external,
            "internal_count": current.total_internal,
            "since_hours": since_hours,
            "timestamp": datetime.now(UTC).isoformat(),
        }

    async def get_external_services(self) -> list[dict[str, Any]]:
        """Get all externally-exposed services."""
        entries = await self._map_external_services()
        return [e.model_dump() for e in entries]

    async def get_risk_summary(self) -> dict[str, Any]:
        """Get a risk summary across all categories."""
        surface = await self.map()
        risk_counts: dict[str, int] = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for entry in surface.entries:
            risk_counts[entry.risk_level] = risk_counts.get(entry.risk_level, 0) + 1

        return {
            "overall_score": surface.overall_score,
            "score_by_category": surface.score_by_category,
            "risk_counts": risk_counts,
            "total_entries": len(surface.entries),
            "external_exposure": surface.total_external,
            "timestamp": datetime.now(UTC).isoformat(),
        }

    async def _map_external_services(self) -> list[AttackSurfaceEntry]:
        """Map externally-exposed services from infrastructure connectors."""
        entries: list[AttackSurfaceEntry] = []

        if self._router is None:
            return entries

        try:
            from shieldops.models.base import Environment

            for provider in self._router.providers:
                connector = self._router.get(provider)
                try:
                    resources = await connector.list_resources("service", Environment.PRODUCTION)
                    for r in resources:
                        is_external = (
                            r.labels.get("exposure") == "external"
                            or r.labels.get("type") == "LoadBalancer"
                        )
                        entries.append(
                            AttackSurfaceEntry(
                                resource_id=r.id,
                                resource_type=r.resource_type,
                                category="network",
                                risk_level="high" if is_external else "low",
                                exposure="external" if is_external else "internal",
                                details={
                                    "provider": provider,
                                    "labels": dict(r.labels) if r.labels else {},
                                },
                                recommendations=(
                                    ["Review external exposure and restrict access if possible"]
                                    if is_external
                                    else []
                                ),
                            )
                        )
                except Exception as e:
                    logger.warning(
                        "attack_surface_provider_failed",
                        provider=provider,
                        error=str(e),
                    )
        except Exception as e:
            logger.warning("attack_surface_external_failed", error=str(e))

        return entries

    async def _map_exposed_resources(self) -> list[AttackSurfaceEntry]:
        """Map resources with network exposure from vulnerability data."""
        entries: list[AttackSurfaceEntry] = []

        if self._repository is None:
            return entries

        try:
            vulns = await self._repository.list_vulnerabilities(scanner_type="network", limit=100)
            for v in vulns:
                entries.append(
                    AttackSurfaceEntry(
                        resource_id=v.get("affected_resource", ""),
                        resource_type="network_finding",
                        category="network",
                        risk_level=v.get("severity", "medium"),
                        exposure="external",
                        details={"finding": v.get("title", ""), "cve_id": v.get("cve_id", "")},
                        recommendations=[
                            v.get("remediation", "Review and remediate network exposure")
                        ],
                    )
                )
        except Exception as e:
            logger.warning("attack_surface_exposed_failed", error=str(e))

        return entries

    async def _map_iam_risks(self) -> list[AttackSurfaceEntry]:
        """Map IAM-related risks from credential stores."""
        entries: list[AttackSurfaceEntry] = []

        for store in self._credential_stores:
            try:
                creds = await store.list_credentials()
                now = datetime.now(UTC)
                for cred in creds:
                    expires_at = cred.get("expires_at")
                    risk = "low"
                    recommendations: list[str] = []

                    if expires_at and expires_at <= now:
                        risk = "critical"
                        recommendations.append("Rotate expired credential immediately")
                    elif not cred.get("last_rotated"):
                        risk = "medium"
                        recommendations.append("Set up credential rotation policy")

                    entries.append(
                        AttackSurfaceEntry(
                            resource_id=cred.get("credential_id", ""),
                            resource_type="credential",
                            category="identity",
                            risk_level=risk,
                            exposure="internal",
                            details={
                                "store": getattr(store, "store_name", "unknown"),
                                "type": cred.get("credential_type", ""),
                            },
                            recommendations=recommendations,
                        )
                    )
            except Exception as e:
                logger.warning("attack_surface_iam_failed", error=str(e))

        return entries

    async def _map_unpatched_services(self) -> list[AttackSurfaceEntry]:
        """Map services with known unpatched vulnerabilities."""
        entries: list[AttackSurfaceEntry] = []

        if self._repository is None:
            return entries

        try:
            vulns = await self._repository.list_vulnerabilities(severity="critical", limit=50)
            for v in vulns:
                if v.get("fixed_version"):
                    entries.append(
                        AttackSurfaceEntry(
                            resource_id=v.get("affected_resource", ""),
                            resource_type="unpatched_service",
                            category="application",
                            risk_level=v.get("severity", "high"),
                            exposure="internal",
                            details={
                                "cve_id": v.get("cve_id", ""),
                                "package": v.get("package_name", ""),
                                "fixed_version": v.get("fixed_version", ""),
                            },
                            recommendations=[
                                f"Patch {v.get('package_name', '')} to {v.get('fixed_version', '')}"
                            ],
                        )
                    )
        except Exception as e:
            logger.warning("attack_surface_unpatched_failed", error=str(e))

        return entries

    async def _map_certificate_status(self) -> list[AttackSurfaceEntry]:
        """Map TLS certificate expiry risks."""
        entries: list[AttackSurfaceEntry] = []

        if self._repository is None:
            return entries

        # Certificate data typically comes from network scans
        try:
            vulns = await self._repository.list_vulnerabilities(scanner_type="network", limit=50)
            for v in vulns:
                title = v.get("title", "").lower()
                if "certificate" in title or "tls" in title or "ssl" in title:
                    entries.append(
                        AttackSurfaceEntry(
                            resource_id=v.get("affected_resource", ""),
                            resource_type="certificate",
                            category="data",
                            risk_level=v.get("severity", "medium"),
                            exposure="external",
                            details={"finding": v.get("title", "")},
                            recommendations=["Renew or replace TLS certificate"],
                        )
                    )
        except Exception as e:
            logger.warning("attack_surface_cert_failed", error=str(e))

        return entries

    def _calculate_category_score(self, entries: list[AttackSurfaceEntry]) -> float:
        """Calculate security score for a category (0-100, higher=better)."""
        if not entries:
            return 100.0

        risk_weights = {"critical": 10.0, "high": 5.0, "medium": 2.0, "low": 0.5}
        total_weight = sum(risk_weights.get(e.risk_level, 1.0) for e in entries)
        penalty = min(100.0, total_weight)
        return max(0.0, 100.0 - penalty)
