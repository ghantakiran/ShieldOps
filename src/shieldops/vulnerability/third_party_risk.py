"""Third-party vendor and dependency risk tracking.

Tracks vendor risk posture, manages periodic assessments, records incidents,
and identifies vendors overdue for reassessment based on configurable intervals.
"""

from __future__ import annotations

import enum
import time
import uuid
from typing import Any

import structlog
from pydantic import BaseModel, Field

logger = structlog.get_logger()


# -- Enums --------------------------------------------------------------------


class VendorRiskLevel(enum.StrEnum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
    UNASSESSED = "unassessed"


class VendorCategory(enum.StrEnum):
    SAAS = "saas"
    OPEN_SOURCE = "open_source"
    INFRASTRUCTURE = "infrastructure"
    DATA_PROCESSOR = "data_processor"
    SECURITY_TOOL = "security_tool"


# -- Models --------------------------------------------------------------------


class VendorRecord(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    name: str
    category: VendorCategory
    risk_level: VendorRiskLevel = VendorRiskLevel.UNASSESSED
    compliance_certifications: list[str] = Field(default_factory=list)
    last_assessment_at: float | None = None
    next_assessment_due: float | None = None
    contact_email: str = ""
    notes: str = ""
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: float = Field(default_factory=time.time)


class RiskAssessment(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    vendor_id: str
    risk_level: VendorRiskLevel
    findings: list[str] = Field(default_factory=list)
    recommendations: list[str] = Field(default_factory=list)
    assessed_by: str = ""
    assessed_at: float = Field(default_factory=time.time)


class VendorIncident(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    vendor_id: str
    title: str
    description: str = ""
    severity: str = "medium"
    impact: str = ""
    reported_at: float = Field(default_factory=time.time)
    resolved_at: float | None = None


# -- Engine --------------------------------------------------------------------


class ThirdPartyRiskTracker:
    """Track vendor risk, assessments, and incidents.

    Parameters
    ----------
    max_vendors:
        Maximum vendor records to store.
    assessment_interval_days:
        Default number of days between reassessments.
    """

    def __init__(
        self,
        max_vendors: int = 500,
        assessment_interval_days: int = 90,
    ) -> None:
        self._vendors: dict[str, VendorRecord] = {}
        self._assessments: list[RiskAssessment] = []
        self._incidents: list[VendorIncident] = []
        self._max_vendors = max_vendors
        self._assessment_interval_days = assessment_interval_days

    def register_vendor(
        self,
        name: str,
        category: VendorCategory,
        compliance_certifications: list[str] | None = None,
        contact_email: str = "",
        notes: str = "",
        metadata: dict[str, Any] | None = None,
    ) -> VendorRecord:
        if len(self._vendors) >= self._max_vendors:
            raise ValueError(f"Maximum vendors limit reached: {self._max_vendors}")
        vendor = VendorRecord(
            name=name,
            category=category,
            compliance_certifications=compliance_certifications or [],
            contact_email=contact_email,
            notes=notes,
            metadata=metadata or {},
        )
        self._vendors[vendor.id] = vendor
        logger.info("vendor_registered", vendor_id=vendor.id, name=name)
        return vendor

    def assess_vendor(
        self,
        vendor_id: str,
        risk_level: VendorRiskLevel,
        findings: list[str] | None = None,
        recommendations: list[str] | None = None,
        assessed_by: str = "",
    ) -> RiskAssessment:
        vendor = self._vendors.get(vendor_id)
        if vendor is None:
            raise ValueError(f"Vendor not found: {vendor_id}")
        now = time.time()
        assessment = RiskAssessment(
            vendor_id=vendor_id,
            risk_level=risk_level,
            findings=findings or [],
            recommendations=recommendations or [],
            assessed_by=assessed_by,
            assessed_at=now,
        )
        self._assessments.append(assessment)
        # Update the vendor record
        vendor.risk_level = risk_level
        vendor.last_assessment_at = now
        vendor.next_assessment_due = now + (self._assessment_interval_days * 86400)
        logger.info(
            "vendor_assessed",
            vendor_id=vendor_id,
            risk_level=risk_level,
        )
        return assessment

    def report_incident(
        self,
        vendor_id: str,
        title: str,
        description: str = "",
        severity: str = "medium",
        impact: str = "",
    ) -> VendorIncident:
        if vendor_id not in self._vendors:
            raise ValueError(f"Vendor not found: {vendor_id}")
        incident = VendorIncident(
            vendor_id=vendor_id,
            title=title,
            description=description,
            severity=severity,
            impact=impact,
        )
        self._incidents.append(incident)
        logger.info(
            "vendor_incident_reported",
            incident_id=incident.id,
            vendor_id=vendor_id,
            title=title,
        )
        return incident

    def resolve_incident(self, incident_id: str) -> VendorIncident | None:
        for incident in self._incidents:
            if incident.id == incident_id:
                incident.resolved_at = time.time()
                logger.info("vendor_incident_resolved", incident_id=incident_id)
                return incident
        return None

    def get_vendor(self, vendor_id: str) -> VendorRecord | None:
        return self._vendors.get(vendor_id)

    def list_vendors(
        self,
        risk_level: VendorRiskLevel | None = None,
        category: VendorCategory | None = None,
    ) -> list[VendorRecord]:
        vendors = list(self._vendors.values())
        if risk_level:
            vendors = [v for v in vendors if v.risk_level == risk_level]
        if category:
            vendors = [v for v in vendors if v.category == category]
        return vendors

    def delete_vendor(self, vendor_id: str) -> bool:
        return self._vendors.pop(vendor_id, None) is not None

    def get_overdue_assessments(self) -> list[VendorRecord]:
        now = time.time()
        overdue: list[VendorRecord] = []
        for vendor in self._vendors.values():
            if vendor.next_assessment_due is not None and now > vendor.next_assessment_due:
                overdue.append(vendor)
            elif vendor.last_assessment_at is None:
                # Never assessed = overdue
                overdue.append(vendor)
        return overdue

    def list_incidents(
        self,
        vendor_id: str | None = None,
        active_only: bool = False,
    ) -> list[VendorIncident]:
        incidents = list(self._incidents)
        if vendor_id:
            incidents = [i for i in incidents if i.vendor_id == vendor_id]
        if active_only:
            incidents = [i for i in incidents if i.resolved_at is None]
        return incidents

    def get_stats(self) -> dict[str, Any]:
        risk_dist: dict[str, int] = {}
        for vendor in self._vendors.values():
            level = vendor.risk_level
            risk_dist[level] = risk_dist.get(level, 0) + 1
        active_incidents = sum(1 for i in self._incidents if i.resolved_at is None)
        return {
            "total_vendors": len(self._vendors),
            "total_assessments": len(self._assessments),
            "total_incidents": len(self._incidents),
            "active_incidents": active_incidents,
            "overdue_assessments": len(self.get_overdue_assessments()),
            "risk_distribution": risk_dist,
        }
