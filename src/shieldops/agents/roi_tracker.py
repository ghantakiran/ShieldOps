"""Agent ROI tracking for measuring business impact of automated actions.

Records the monetary value and time savings of agent-driven actions across
investigation, remediation, security patching, cost optimization, and
prediction categories to quantify platform ROI.
"""

from __future__ import annotations

import enum
import time
import uuid
from typing import Any

import structlog
from pydantic import BaseModel, Field

logger = structlog.get_logger()


# -- Enums --------------------------------------------------------------------


class ImpactCategory(enum.StrEnum):
    COST_SAVINGS = "cost_savings"
    TIME_SAVINGS = "time_savings"
    INCIDENT_PREVENTION = "incident_prevention"
    SECURITY_FIX = "security_fix"
    COMPLIANCE = "compliance"


class AgentActionType(enum.StrEnum):
    INVESTIGATION = "investigation"
    REMEDIATION = "remediation"
    SECURITY_PATCH = "security_patch"
    COST_OPTIMIZATION = "cost_optimization"
    PREDICTION = "prediction"


# -- Models --------------------------------------------------------------------


class ROIEntry(BaseModel):
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:12])
    agent_id: str
    agent_type: AgentActionType
    category: ImpactCategory
    description: str = ""
    monetary_value: float = 0.0
    time_saved_minutes: float = 0.0
    currency: str = "USD"
    metadata: dict[str, Any] = Field(default_factory=dict)
    recorded_at: float = Field(default_factory=time.time)


class AgentROIReport(BaseModel):
    agent_type: str
    total_entries: int = 0
    total_monetary_value: float = 0.0
    total_time_saved_minutes: float = 0.0
    top_category: str = ""
    currency: str = "USD"


class ROISummary(BaseModel):
    total_value: float = 0.0
    total_time_saved_hours: float = 0.0
    by_agent_type: dict[str, float] = Field(default_factory=dict)
    by_category: dict[str, float] = Field(default_factory=dict)
    period: str = ""


# -- Engine --------------------------------------------------------------------


class AgentROITracker:
    """Track ROI generated by autonomous agent actions.

    Parameters
    ----------
    max_entries:
        Maximum ROI entries to store.
    """

    def __init__(self, max_entries: int = 100000) -> None:
        self._entries: list[ROIEntry] = []
        self._max_entries = max_entries

    def record_impact(
        self,
        agent_id: str,
        agent_type: AgentActionType,
        category: ImpactCategory,
        description: str = "",
        monetary_value: float = 0.0,
        time_saved_minutes: float = 0.0,
        currency: str = "USD",
        metadata: dict[str, Any] | None = None,
    ) -> ROIEntry:
        if len(self._entries) >= self._max_entries:
            raise ValueError(f"Maximum entries limit reached: {self._max_entries}")
        entry = ROIEntry(
            agent_id=agent_id,
            agent_type=agent_type,
            category=category,
            description=description,
            monetary_value=monetary_value,
            time_saved_minutes=time_saved_minutes,
            currency=currency,
            metadata=metadata or {},
        )
        self._entries.append(entry)
        logger.info(
            "roi_impact_recorded",
            entry_id=entry.id,
            agent_id=agent_id,
            agent_type=agent_type,
            monetary_value=monetary_value,
        )
        return entry

    def get_agent_report(self, agent_type: AgentActionType) -> AgentROIReport:
        matching = [e for e in self._entries if e.agent_type == agent_type]
        if not matching:
            return AgentROIReport(agent_type=agent_type)

        total_value = sum(e.monetary_value for e in matching)
        total_time = sum(e.time_saved_minutes for e in matching)

        # Find top category by monetary value
        cat_totals: dict[str, float] = {}
        for entry in matching:
            cat_totals[entry.category] = cat_totals.get(entry.category, 0) + entry.monetary_value
        top_category = max(cat_totals, key=cat_totals.get) if cat_totals else ""  # type: ignore[arg-type]

        return AgentROIReport(
            agent_type=agent_type,
            total_entries=len(matching),
            total_monetary_value=round(total_value, 2),
            total_time_saved_minutes=round(total_time, 2),
            top_category=top_category,
        )

    def get_summary(self, period: str = "") -> ROISummary:
        total_value = sum(e.monetary_value for e in self._entries)
        total_minutes = sum(e.time_saved_minutes for e in self._entries)

        by_agent: dict[str, float] = {}
        for entry in self._entries:
            by_agent[entry.agent_type] = by_agent.get(entry.agent_type, 0) + entry.monetary_value

        by_category: dict[str, float] = {}
        for entry in self._entries:
            by_category[entry.category] = by_category.get(entry.category, 0) + entry.monetary_value

        return ROISummary(
            total_value=round(total_value, 2),
            total_time_saved_hours=round(total_minutes / 60, 2),
            by_agent_type=by_agent,
            by_category=by_category,
            period=period,
        )

    def get_top_agents(self, limit: int = 10) -> list[dict[str, Any]]:
        agent_totals: dict[str, dict[str, Any]] = {}
        for entry in self._entries:
            if entry.agent_id not in agent_totals:
                agent_totals[entry.agent_id] = {
                    "agent_id": entry.agent_id,
                    "agent_type": entry.agent_type,
                    "total_value": 0.0,
                    "total_time_saved_minutes": 0.0,
                    "entry_count": 0,
                }
            agg = agent_totals[entry.agent_id]
            agg["total_value"] += entry.monetary_value
            agg["total_time_saved_minutes"] += entry.time_saved_minutes
            agg["entry_count"] += 1

        ranked = sorted(
            agent_totals.values(),
            key=lambda a: a["total_value"],
            reverse=True,
        )
        return ranked[:limit]

    def list_entries(
        self,
        agent_type: AgentActionType | None = None,
        category: ImpactCategory | None = None,
        limit: int = 100,
    ) -> list[ROIEntry]:
        entries = list(self._entries)
        if agent_type:
            entries = [e for e in entries if e.agent_type == agent_type]
        if category:
            entries = [e for e in entries if e.category == category]
        return entries[-limit:]

    def get_category_breakdown(self) -> dict[str, float]:
        breakdown: dict[str, float] = {}
        for entry in self._entries:
            breakdown[entry.category] = breakdown.get(entry.category, 0) + entry.monetary_value
        return breakdown

    def get_time_series(self, bucket_hours: int = 24) -> list[dict[str, Any]]:
        if not self._entries:
            return []
        bucket_seconds = bucket_hours * 3600
        # Determine time range
        min_time = min(e.recorded_at for e in self._entries)
        max_time = max(e.recorded_at for e in self._entries)

        buckets: dict[float, dict[str, Any]] = {}
        current = min_time
        while current <= max_time + bucket_seconds:
            buckets[current] = {
                "bucket_start": current,
                "bucket_end": current + bucket_seconds,
                "total_value": 0.0,
                "total_time_saved_minutes": 0.0,
                "entry_count": 0,
            }
            current += bucket_seconds

        for entry in self._entries:
            # Find which bucket this entry belongs to
            offset = (entry.recorded_at - min_time) // bucket_seconds
            bucket_key = min_time + offset * bucket_seconds
            if bucket_key in buckets:
                buckets[bucket_key]["total_value"] += entry.monetary_value
                buckets[bucket_key]["total_time_saved_minutes"] += entry.time_saved_minutes
                buckets[bucket_key]["entry_count"] += 1

        return sorted(buckets.values(), key=lambda b: b["bucket_start"])

    def get_stats(self) -> dict[str, Any]:
        total_value = sum(e.monetary_value for e in self._entries)
        total_minutes = sum(e.time_saved_minutes for e in self._entries)
        unique_agents = {e.agent_id for e in self._entries}
        return {
            "total_entries": len(self._entries),
            "total_monetary_value": round(total_value, 2),
            "total_time_saved_minutes": round(total_minutes, 2),
            "unique_agents": len(unique_agents),
            "agent_types": sorted({e.agent_type for e in self._entries}),
            "categories": sorted({e.category for e in self._entries}),
        }
