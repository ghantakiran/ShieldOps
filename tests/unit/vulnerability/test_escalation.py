"""Tests for EscalationEngine — time-based SLA breach escalation.

Covers:
- Engine initialization
- register_chain — custom chain registered for team
- get_chain — returns custom chain or default fallback
- check_and_escalate — SLA breach triggers team lead notification
- check_and_escalate — 2x SLA breach triggers eng manager
- check_and_escalate — critical unpatched >48h triggers CISO
- _should_escalate logic for each condition type
- _trigger_escalation — dispatcher called correctly
- Error handling when repository or dispatcher fails
"""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from types import SimpleNamespace
from unittest.mock import AsyncMock

import pytest

from shieldops.vulnerability.escalation import (
    DEFAULT_ESCALATION_RULES,
    EscalationChain,
    EscalationEngine,
    EscalationRule,
)

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _make_vuln(
    vuln_id="vuln-1",
    cve_id="CVE-2024-0001",
    severity="critical",
    sla_breached=True,
    sla_due_at=None,
    first_seen_at=None,
    assigned_team_id=None,
    status="new",
):
    """Create a mock vulnerability with the attributes the engine reads."""
    now = datetime.now(UTC)
    return SimpleNamespace(
        id=vuln_id,
        cve_id=cve_id,
        severity=severity,
        sla_breached=sla_breached,
        sla_due_at=sla_due_at or now - timedelta(hours=6),
        first_seen_at=first_seen_at or now - timedelta(days=3),
        assigned_team_id=assigned_team_id,
        status=status,
    )


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture()
def mock_repository() -> AsyncMock:
    repo = AsyncMock()
    repo.list_vulnerabilities = AsyncMock(return_value=[])
    return repo


@pytest.fixture()
def mock_dispatcher() -> AsyncMock:
    return AsyncMock()


@pytest.fixture()
def engine(mock_repository, mock_dispatcher) -> EscalationEngine:
    return EscalationEngine(
        repository=mock_repository,
        notification_dispatcher=mock_dispatcher,
    )


@pytest.fixture()
def engine_no_dispatcher(mock_repository) -> EscalationEngine:
    return EscalationEngine(repository=mock_repository, notification_dispatcher=None)


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestEscalationEngineInit:
    def test_init_stores_deps(self, engine: EscalationEngine):
        assert engine._repository is not None
        assert engine._dispatcher is not None
        assert engine._chains == {}


class TestRegisterChain:
    def test_register_stores_chain(self, engine: EscalationEngine):
        chain = EscalationChain(
            team_id="team-sec",
            rules=[
                EscalationRule(
                    name="custom_rule",
                    condition="sla_breach",
                    delay_hours=0,
                    notify_role="team_lead",
                    channel="slack",
                ),
            ],
        )
        engine.register_chain(chain)
        assert "team-sec" in engine._chains
        assert len(engine._chains["team-sec"].rules) == 1


class TestGetChain:
    def test_returns_custom_chain_when_registered(self, engine: EscalationEngine):
        custom = EscalationChain(team_id="team-sec", rules=[])
        engine.register_chain(custom)
        chain = engine.get_chain("team-sec")
        assert chain is custom

    def test_returns_default_when_no_custom(self, engine: EscalationEngine):
        chain = engine.get_chain("unknown-team")
        assert chain.team_id == "unknown-team"
        assert chain.rules == DEFAULT_ESCALATION_RULES


class TestShouldEscalate:
    def test_sla_breach_condition(self, engine: EscalationEngine):
        vuln = _make_vuln(sla_breached=True)
        rule = EscalationRule(
            name="r1",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
        )
        assert engine._should_escalate(vuln, rule) is True

    def test_sla_breach_not_breached(self, engine: EscalationEngine):
        vuln = _make_vuln(sla_breached=False)
        rule = EscalationRule(
            name="r1",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
        )
        assert engine._should_escalate(vuln, rule) is False

    def test_sla_breach_2x_condition(self, engine: EscalationEngine):
        now = datetime.now(UTC)
        # first_seen 10 days ago, SLA due 5 days ago => overdue 5 days, SLA duration 5 days => 1x
        # Need overdue > duration: first_seen 10d ago, due 7d ago => dur=3d, overdue=7d => 2.3x
        vuln = _make_vuln(
            sla_breached=True,
            first_seen_at=now - timedelta(days=10),
            sla_due_at=now - timedelta(days=7),
        )
        rule = EscalationRule(
            name="r2",
            condition="sla_breach_2x",
            delay_hours=0,
            notify_role="eng_manager",
            channel="pagerduty",
        )
        assert engine._should_escalate(vuln, rule) is True

    def test_sla_breach_2x_not_enough_overdue(self, engine: EscalationEngine):
        now = datetime.now(UTC)
        # first_seen 10 days ago, SLA due 1 hour ago => dur=~10d, overdue=1h => not 2x
        vuln = _make_vuln(
            sla_breached=True,
            first_seen_at=now - timedelta(days=10),
            sla_due_at=now - timedelta(hours=1),
        )
        rule = EscalationRule(
            name="r2",
            condition="sla_breach_2x",
            delay_hours=0,
            notify_role="eng_manager",
            channel="pagerduty",
        )
        assert engine._should_escalate(vuln, rule) is False

    def test_critical_unpatched_48h_condition(self, engine: EscalationEngine):
        now = datetime.now(UTC)
        vuln = _make_vuln(
            severity="critical",
            first_seen_at=now - timedelta(hours=72),
            sla_due_at=now - timedelta(hours=24),
        )
        rule = EscalationRule(
            name="r3",
            condition="critical_unpatched_48h",
            delay_hours=0,
            notify_role="ciso",
            channel="email",
        )
        assert engine._should_escalate(vuln, rule) is True

    def test_critical_unpatched_under_48h(self, engine: EscalationEngine):
        now = datetime.now(UTC)
        vuln = _make_vuln(
            severity="critical",
            first_seen_at=now - timedelta(hours=24),
            sla_due_at=now - timedelta(hours=1),
        )
        rule = EscalationRule(
            name="r3",
            condition="critical_unpatched_48h",
            delay_hours=0,
            notify_role="ciso",
            channel="email",
        )
        assert engine._should_escalate(vuln, rule) is False

    def test_returns_false_when_no_sla_due(self, engine: EscalationEngine):
        vuln = SimpleNamespace(
            id="v1",
            cve_id="",
            severity="high",
            sla_breached=True,
            sla_due_at=None,
            first_seen_at=datetime.now(UTC),
        )
        rule = EscalationRule(
            name="r1",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
        )
        assert engine._should_escalate(vuln, rule) is False

    def test_unknown_condition_returns_false(self, engine: EscalationEngine):
        vuln = _make_vuln(sla_due_at=datetime.now(UTC) - timedelta(hours=1))
        rule = EscalationRule(
            name="r_unknown",
            condition="unknown_condition",
            delay_hours=0,
            notify_role="ciso",
            channel="email",
        )
        assert engine._should_escalate(vuln, rule) is False


class TestCheckAndEscalate:
    """End-to-end escalation check."""

    @pytest.mark.asyncio
    async def test_sla_breach_triggers_team_lead(
        self, engine: EscalationEngine, mock_repository: AsyncMock, mock_dispatcher: AsyncMock
    ):
        vuln = _make_vuln(sla_breached=True)
        mock_repository.list_vulnerabilities.side_effect = [
            [vuln],  # SLA breached call
            [],  # Critical unpatched call
        ]
        result = await engine.check_and_escalate()
        assert result["escalations_triggered"] >= 1
        mock_dispatcher.send_notification.assert_awaited()

    @pytest.mark.asyncio
    async def test_critical_unpatched_48h_triggers_ciso(
        self, engine: EscalationEngine, mock_repository: AsyncMock, mock_dispatcher: AsyncMock
    ):
        now = datetime.now(UTC)
        vuln = _make_vuln(
            severity="critical",
            first_seen_at=now - timedelta(hours=72),
        )
        mock_repository.list_vulnerabilities.side_effect = [
            [],  # SLA breached — empty
            [vuln],  # Critical unpatched
        ]
        result = await engine.check_and_escalate()
        assert result["escalations_triggered"] >= 1
        # Verify CISO notification channel
        calls = mock_dispatcher.send_notification.call_args_list
        assert any(c.kwargs.get("channel") == "email" for c in calls)

    @pytest.mark.asyncio
    async def test_no_escalations_when_all_clear(
        self, engine: EscalationEngine, mock_repository: AsyncMock
    ):
        mock_repository.list_vulnerabilities.return_value = []
        result = await engine.check_and_escalate()
        assert result["escalations_triggered"] == 0

    @pytest.mark.asyncio
    async def test_handles_repo_exception(
        self, engine: EscalationEngine, mock_repository: AsyncMock
    ):
        mock_repository.list_vulnerabilities.side_effect = RuntimeError("DB down")
        result = await engine.check_and_escalate()
        assert result["escalations_triggered"] == 0


class TestTriggerEscalation:
    @pytest.mark.asyncio
    async def test_sends_notification(self, engine: EscalationEngine, mock_dispatcher: AsyncMock):
        vuln = _make_vuln()
        rule = EscalationRule(
            name="test_rule",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
            priority="high",
        )
        result = await engine._trigger_escalation(vuln, rule, "team-sec")
        assert result is not None
        assert result["vuln_id"] == "vuln-1"
        assert result["rule"] == "test_rule"
        assert result["channel"] == "slack"
        mock_dispatcher.send_notification.assert_awaited_once()

    @pytest.mark.asyncio
    async def test_still_returns_result_without_dispatcher(
        self, engine_no_dispatcher: EscalationEngine
    ):
        vuln = _make_vuln()
        rule = EscalationRule(
            name="test_rule",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
        )
        result = await engine_no_dispatcher._trigger_escalation(vuln, rule, "team-x")
        assert result is not None
        assert result["vuln_id"] == "vuln-1"

    @pytest.mark.asyncio
    async def test_handles_dispatcher_exception(
        self, engine: EscalationEngine, mock_dispatcher: AsyncMock
    ):
        mock_dispatcher.send_notification.side_effect = RuntimeError("Slack down")
        vuln = _make_vuln()
        rule = EscalationRule(
            name="test_rule",
            condition="sla_breach",
            delay_hours=0,
            notify_role="team_lead",
            channel="slack",
        )
        # Should not raise; the exception is logged and a result is still returned
        result = await engine._trigger_escalation(vuln, rule, "team-sec")
        assert result is not None
