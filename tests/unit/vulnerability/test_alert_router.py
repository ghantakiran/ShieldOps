"""Tests for the vulnerability alert routing engine.

Tests cover:
- Routing new vulnerabilities to owning teams
- SLA breach escalation with severity upgrade
- Team finding by resource name heuristic
- Scanner-type-based fallback routing
- Notification dispatch (Slack, PagerDuty, broadcast)
- Edge cases: no teams, no dispatcher, no repository
"""

from typing import Any
from unittest.mock import AsyncMock

import pytest

from shieldops.vulnerability.alert_router import AlertRouter


def _make_vuln(
    vuln_id: str = "vuln-001",
    severity: str = "high",
    affected_resource: str = "aws:nginx-prod-instance",
    scanner_type: str = "cve",
    title: str = "CVE-2024-1234",
) -> dict[str, Any]:
    return {
        "id": vuln_id,
        "severity": severity,
        "affected_resource": affected_resource,
        "scanner_type": scanner_type,
        "title": title,
        "cve_id": "CVE-2024-1234",
        "assigned_team_id": None,
    }


def _make_team(
    team_id: str = "team-1",
    name: str = "platform",
    slack_channel: str = "#platform-alerts",
    pagerduty_service_id: str = "PD123",
) -> dict[str, Any]:
    return {
        "id": team_id,
        "name": name,
        "slack_channel": slack_channel,
        "pagerduty_service_id": pagerduty_service_id,
    }


@pytest.fixture
def mock_repo() -> AsyncMock:
    repo = AsyncMock()
    repo.list_teams = AsyncMock(return_value=[_make_team()])
    repo.assign_vulnerability = AsyncMock(return_value=True)
    repo.get_team = AsyncMock(return_value=_make_team())
    return repo


@pytest.fixture
def mock_dispatcher() -> AsyncMock:
    dispatcher = AsyncMock()
    dispatcher.send = AsyncMock()
    dispatcher.send_escalation = AsyncMock()
    dispatcher.broadcast = AsyncMock()
    return dispatcher


@pytest.fixture
def router(mock_repo: AsyncMock, mock_dispatcher: AsyncMock) -> AlertRouter:
    return AlertRouter(repository=mock_repo, dispatcher=mock_dispatcher)


@pytest.fixture
def router_no_deps() -> AlertRouter:
    return AlertRouter(repository=None, dispatcher=None)


# ============================================================================
# Route new vulnerability
# ============================================================================


class TestRouteNewVulnerability:
    @pytest.mark.asyncio
    async def test_routes_to_matching_team(self, router: AlertRouter, mock_repo: AsyncMock) -> None:
        vuln = _make_vuln(affected_resource="platform-service-prod")
        result = await router.route_new_vulnerability(vuln)

        assert result["routed"] is True
        assert result["team_id"] == "team-1"
        assert result["team_name"] == "platform"
        mock_repo.assign_vulnerability.assert_called_once()

    @pytest.mark.asyncio
    async def test_no_teams_returns_unrouted(self, mock_dispatcher: AsyncMock) -> None:
        repo = AsyncMock()
        repo.list_teams = AsyncMock(return_value=[])
        router = AlertRouter(repository=repo, dispatcher=mock_dispatcher)

        vuln = _make_vuln()
        result = await router.route_new_vulnerability(vuln)

        assert result["routed"] is False
        assert result["team_id"] is None

    @pytest.mark.asyncio
    async def test_no_repo_returns_unrouted(self, router_no_deps: AlertRouter) -> None:
        vuln = _make_vuln()
        result = await router_no_deps.route_new_vulnerability(vuln)
        assert result["routed"] is False

    @pytest.mark.asyncio
    async def test_scanner_type_fallback_routing(
        self, router: AlertRouter, mock_repo: AsyncMock
    ) -> None:
        # No team name match, but scanner_type=iac should map to "platform" team
        mock_repo.list_teams.return_value = [_make_team(name="platform")]
        vuln = _make_vuln(
            affected_resource="some-random-resource",
            scanner_type="iac",
        )
        result = await router.route_new_vulnerability(vuln)

        assert result["routed"] is True
        assert result["team_name"] == "platform"

    @pytest.mark.asyncio
    async def test_default_fallback_to_first_team(
        self, router: AlertRouter, mock_repo: AsyncMock
    ) -> None:
        mock_repo.list_teams.return_value = [_make_team(name="catch-all")]
        vuln = _make_vuln(
            affected_resource="xyz-no-match",
            scanner_type="unknown_type",
        )
        result = await router.route_new_vulnerability(vuln)

        assert result["routed"] is True
        assert result["team_name"] == "catch-all"


# ============================================================================
# Notification on route
# ============================================================================


class TestNotification:
    @pytest.mark.asyncio
    async def test_slack_notification_sent(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(affected_resource="platform-service")
        await router.route_new_vulnerability(vuln)

        mock_dispatcher.send.assert_called()
        call_args = mock_dispatcher.send.call_args
        assert call_args[0][0] == "slack"

    @pytest.mark.asyncio
    async def test_pagerduty_for_critical(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="critical", affected_resource="platform-service")
        await router.route_new_vulnerability(vuln)

        mock_dispatcher.send_escalation.assert_called()

    @pytest.mark.asyncio
    async def test_no_pagerduty_for_low(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="low", affected_resource="platform-service")
        await router.route_new_vulnerability(vuln)

        mock_dispatcher.send_escalation.assert_not_called()

    @pytest.mark.asyncio
    async def test_no_dispatcher_does_not_crash(self, mock_repo: AsyncMock) -> None:
        router = AlertRouter(repository=mock_repo, dispatcher=None)
        vuln = _make_vuln(affected_resource="platform-service")
        # Should not raise
        result = await router.route_new_vulnerability(vuln)
        assert result["routed"] is True


# ============================================================================
# SLA breach escalation
# ============================================================================


class TestRouteSLABreach:
    @pytest.mark.asyncio
    async def test_escalation_sent(
        self, router: AlertRouter, mock_repo: AsyncMock, mock_dispatcher: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="high")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 10.0, "breach_multiplier": 0.5}

        result = await router.route_sla_breach(vuln, breach)

        assert result["escalated"] is True
        assert result["team_id"] == "team-1"

    @pytest.mark.asyncio
    async def test_no_dispatcher_returns_not_escalated(self, mock_repo: AsyncMock) -> None:
        router = AlertRouter(repository=mock_repo, dispatcher=None)
        vuln = _make_vuln()
        breach = {"time_overdue_hours": 10.0, "breach_multiplier": 0.5}

        result = await router.route_sla_breach(vuln, breach)
        assert result["escalated"] is False
        assert result["reason"] == "no dispatcher"

    @pytest.mark.asyncio
    async def test_breach_multiplier_upgrades_severity(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="medium")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 200.0, "breach_multiplier": 2.5}

        result = await router.route_sla_breach(vuln, breach)

        assert result["escalation_severity"] == "critical"

    @pytest.mark.asyncio
    async def test_breach_multiplier_1x_upgrades_to_high(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="medium")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 100.0, "breach_multiplier": 1.5}

        result = await router.route_sla_breach(vuln, breach)

        assert result["escalation_severity"] == "high"

    @pytest.mark.asyncio
    async def test_critical_breach_broadcasts(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="high")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 200.0, "breach_multiplier": 3.0}

        await router.route_sla_breach(vuln, breach)

        mock_dispatcher.broadcast.assert_called_once()

    @pytest.mark.asyncio
    async def test_non_critical_does_not_broadcast(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="low")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 5.0, "breach_multiplier": 0.3}

        await router.route_sla_breach(vuln, breach)

        mock_dispatcher.broadcast.assert_not_called()

    @pytest.mark.asyncio
    async def test_pagerduty_escalation_for_critical(
        self, router: AlertRouter, mock_dispatcher: AsyncMock, mock_repo: AsyncMock
    ) -> None:
        vuln = _make_vuln(severity="critical")
        vuln["assigned_team_id"] = "team-1"
        breach = {"time_overdue_hours": 30.0, "breach_multiplier": 0.8}

        await router.route_sla_breach(vuln, breach)

        mock_dispatcher.send_escalation.assert_called()
        call_kwargs = mock_dispatcher.send_escalation.call_args.kwargs
        assert call_kwargs["source"] == "shieldops-sla"


# ============================================================================
# Team finding logic
# ============================================================================


class TestFindOwningTeam:
    @pytest.mark.asyncio
    async def test_name_match_in_resource(self, router: AlertRouter) -> None:
        team = await router._find_owning_team("platform-api-prod", "cve")
        assert team is not None
        assert team["name"] == "platform"

    @pytest.mark.asyncio
    async def test_scanner_type_fallback(self, router: AlertRouter, mock_repo: AsyncMock) -> None:
        mock_repo.list_teams.return_value = [_make_team(name="security")]
        team = await router._find_owning_team("unrelated-resource", "secret")
        assert team is not None
        assert team["name"] == "security"

    @pytest.mark.asyncio
    async def test_returns_first_team_as_last_resort(
        self, router: AlertRouter, mock_repo: AsyncMock
    ) -> None:
        mock_repo.list_teams.return_value = [_make_team(name="default-team")]
        team = await router._find_owning_team("no-match", "unknown")
        assert team is not None
        assert team["name"] == "default-team"

    @pytest.mark.asyncio
    async def test_no_repo_returns_none(self, router_no_deps: AlertRouter) -> None:
        team = await router_no_deps._find_owning_team("anything", "cve")
        assert team is None

    @pytest.mark.asyncio
    async def test_no_teams_returns_none(self, router: AlertRouter, mock_repo: AsyncMock) -> None:
        mock_repo.list_teams.return_value = []
        team = await router._find_owning_team("anything", "cve")
        assert team is None
