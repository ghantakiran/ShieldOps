"""Tests for PlaybookMatcher — matches vulnerability findings to playbooks.

Covers:
- PlaybookMatcher initialization (with and without loader)
- match — critical CVE matches cve-critical-patch playbook
- match — secret leak matches secret-leak-response playbook
- match — IaC finding matches iac-misconfig-fix playbook
- match — network exposure matches network-exposure-fix playbook
- match — K8s RBAC matches k8s-rbac-remediation playbook
- match — K8s pod security matches k8s-rbac-remediation playbook
- match — no match returns empty list
- get_remediation_steps — returns steps from matched playbook
- get_remediation_steps — falls back to generic steps
- add_mapping — custom mappings take precedence over defaults
- _detect_patterns — correct patterns for different vuln types
- _generic_steps — covers CVE, secret, IaC, network, and default paths
"""

from __future__ import annotations

from types import SimpleNamespace
from unittest.mock import MagicMock

import pytest

from shieldops.vulnerability.playbook_matcher import PlaybookMatcher

# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture()
def mock_loader() -> MagicMock:
    """Playbook loader that returns a playbook object for any path."""
    loader = MagicMock()
    loader.get.side_effect = lambda path: SimpleNamespace(
        name=path,
        steps=[
            {"description": f"Step 1 for {path}", "name": "step1"},
            {"description": f"Step 2 for {path}", "name": "step2"},
        ],
        description=f"Playbook at {path}",
    )
    return loader


@pytest.fixture()
def matcher() -> PlaybookMatcher:
    """Matcher without a loader — uses stub playbooks."""
    return PlaybookMatcher()


@pytest.fixture()
def matcher_with_loader(mock_loader) -> PlaybookMatcher:
    return PlaybookMatcher(playbook_loader=mock_loader)


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestPlaybookMatcherInit:
    def test_init_without_loader(self, matcher: PlaybookMatcher):
        assert matcher._loader is None
        assert matcher._custom_mappings == {}

    def test_init_with_loader(self, matcher_with_loader: PlaybookMatcher):
        assert matcher_with_loader._loader is not None


class TestMatch:
    """Pattern-based playbook matching."""

    def test_critical_cve_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "OpenSSL RCE",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("cve-critical-patch" in m["path"] for m in matches)

    def test_high_cve_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "high",
            "cve_id": "CVE-2024-0002",
            "scanner_type": "",
            "check_type": "",
            "title": "libcurl overflow",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("cve-critical-patch" in m["path"] for m in matches)

    def test_secret_leak_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "git_secrets",
            "check_type": "",
            "title": "AWS key leaked",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("secret-leak-response" in m["path"] for m in matches)

    def test_iac_misconfiguration_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "medium",
            "cve_id": "",
            "scanner_type": "iac",
            "check_type": "",
            "title": "S3 bucket public",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("iac-misconfig-fix" in m["path"] for m in matches)

    def test_checkov_scanner_matches_iac(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "medium",
            "cve_id": "",
            "scanner_type": "checkov",
            "check_type": "",
            "title": "EC2 no encryption",
        }
        matches = matcher.match(vuln)
        assert any("iac-misconfig-fix" in m["path"] for m in matches)

    def test_network_exposure_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "network",
            "check_type": "",
            "title": "Port 22 exposed",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("network-exposure-fix" in m["path"] for m in matches)

    def test_k8s_rbac_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "k8s_security",
            "check_type": "rbac",
            "title": "Cluster admin binding",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("k8s-rbac-remediation" in m["path"] for m in matches)

    def test_k8s_pod_security_matches(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "k8s_security",
            "check_type": "pod",
            "title": "Privileged container",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1
        assert any("k8s-rbac-remediation" in m["path"] for m in matches)

    def test_kubernetes_in_title_triggers_k8s(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "medium",
            "cve_id": "",
            "scanner_type": "",
            "check_type": "",
            "title": "Kubernetes RBAC misconfigured",
        }
        matches = matcher.match(vuln)
        assert len(matches) >= 1

    def test_no_match_returns_empty(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "low",
            "cve_id": "",
            "scanner_type": "custom",
            "check_type": "",
            "title": "Informational finding",
        }
        matches = matcher.match(vuln)
        assert matches == []

    def test_match_with_loader(self, matcher_with_loader: PlaybookMatcher, mock_loader):
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "RCE",
        }
        matches = matcher_with_loader.match(vuln)
        assert len(matches) >= 1
        mock_loader.get.assert_called()
        # Loader-backed playbooks have real steps
        assert len(matches[0]["steps"]) > 0

    def test_loader_exception_returns_no_match(self, mock_loader):
        mock_loader.get.side_effect = RuntimeError("File not found")
        m = PlaybookMatcher(playbook_loader=mock_loader)
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "RCE",
        }
        matches = m.match(vuln)
        assert matches == []


class TestGetRemediationSteps:
    def test_returns_steps_from_matched_playbook(self, matcher_with_loader: PlaybookMatcher):
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "RCE",
        }
        steps = matcher_with_loader.get_remediation_steps(vuln)
        assert len(steps) >= 1
        assert "Step 1" in steps[0]

    def test_deduplicates_steps(self, matcher_with_loader: PlaybookMatcher):
        """If the same playbook path appears for multiple patterns,
        steps should not be duplicated."""
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "RCE",
        }
        steps = matcher_with_loader.get_remediation_steps(vuln)
        assert len(steps) == len(set(steps))

    def test_falls_back_to_generic_steps_for_cve(self, matcher: PlaybookMatcher):
        # Matcher without loader returns stub playbooks with empty steps list
        vuln = {
            "severity": "low",
            "cve_id": "",
            "scanner_type": "custom",
            "check_type": "",
            "title": "Unknown",
        }
        steps = matcher.get_remediation_steps(vuln)
        assert len(steps) >= 2
        assert "Assess" in steps[0]

    def test_matched_playbook_with_empty_steps_returns_empty(self, matcher: PlaybookMatcher):
        # When matcher has no loader, stub playbooks have empty steps.
        # The code returns empty list (match exists but no step content).
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "secret",
            "check_type": "",
            "title": "Exposed key",
        }
        steps = matcher.get_remediation_steps(vuln)
        assert steps == []  # match found, but no steps in stub playbook

    def test_generic_steps_for_iac_no_match(self, matcher: PlaybookMatcher):
        # Use a scanner_type that creates no pattern match but still generic
        m = PlaybookMatcher()
        # "iac" scanner_type actually matches! Use a dummy that doesn't.
        vuln = {
            "severity": "medium",
            "cve_id": "",
            "scanner_type": "unknown",
            "check_type": "",
            "title": "Finding",
        }
        steps = m.get_remediation_steps(vuln)
        assert any("Investigate" in s or "Assess" in s for s in steps)


class TestAddMapping:
    def test_custom_mapping_takes_precedence(self, matcher: PlaybookMatcher):
        matcher.add_mapping("critical_cve", ["custom/my-cve-playbook.yaml"])
        vuln = {
            "severity": "critical",
            "cve_id": "CVE-2024-0001",
            "scanner_type": "",
            "check_type": "",
            "title": "RCE",
        }
        matches = matcher.match(vuln)
        paths = [m["path"] for m in matches]
        # Custom mapping should appear first (before default)
        assert paths[0] == "custom/my-cve-playbook.yaml"

    def test_custom_mapping_for_new_pattern(self, matcher: PlaybookMatcher):
        matcher.add_mapping("dns_hijack", ["security/dns-hijack-response.yaml"])
        # This pattern won't be detected by _detect_patterns, so no match
        vuln = {
            "severity": "high",
            "cve_id": "",
            "scanner_type": "",
            "check_type": "",
            "title": "DNS issue",
        }
        matches = matcher.match(vuln)
        assert matches == []  # Pattern not detected, so custom mapping unused


class TestDetectPatterns:
    @pytest.mark.parametrize(
        "vuln,expected_patterns",
        [
            (
                {
                    "severity": "critical",
                    "cve_id": "CVE-2024-0001",
                    "scanner_type": "",
                    "check_type": "",
                    "title": "",
                },
                ["critical_cve"],
            ),
            (
                {
                    "severity": "high",
                    "cve_id": "CVE-2024-0002",
                    "scanner_type": "",
                    "check_type": "",
                    "title": "",
                },
                ["high_cve"],
            ),
            (
                {
                    "severity": "high",
                    "cve_id": "",
                    "scanner_type": "git_secrets",
                    "check_type": "",
                    "title": "",
                },
                ["secret_leak"],
            ),
            (
                {
                    "severity": "medium",
                    "cve_id": "",
                    "scanner_type": "iac",
                    "check_type": "",
                    "title": "",
                },
                ["iac_misconfiguration"],
            ),
            (
                {
                    "severity": "high",
                    "cve_id": "",
                    "scanner_type": "network",
                    "check_type": "",
                    "title": "",
                },
                ["network_exposure"],
            ),
            (
                {
                    "severity": "high",
                    "cve_id": "",
                    "scanner_type": "k8s_security",
                    "check_type": "rbac",
                    "title": "",
                },
                ["k8s_rbac"],
            ),
        ],
    )
    def test_detect_patterns(self, matcher: PlaybookMatcher, vuln, expected_patterns):
        patterns = matcher._detect_patterns(vuln)
        for expected in expected_patterns:
            assert expected in patterns

    def test_no_patterns_for_generic_vuln(self, matcher: PlaybookMatcher):
        vuln = {
            "severity": "low",
            "cve_id": "",
            "scanner_type": "custom",
            "check_type": "",
            "title": "Informational",
        }
        patterns = matcher._detect_patterns(vuln)
        assert patterns == []


class TestGenericSteps:
    """_generic_steps covers all fallback branches."""

    def test_cve_vuln_steps(self, matcher: PlaybookMatcher):
        vuln = {"severity": "critical", "cve_id": "CVE-2024-0001", "scanner_type": ""}
        steps = matcher._generic_steps(vuln)
        assert any("patch" in s.lower() for s in steps)
        assert any("audit" in s.lower() or "document" in s.lower() for s in steps)

    def test_secret_vuln_steps(self, matcher: PlaybookMatcher):
        vuln = {"severity": "high", "cve_id": "", "scanner_type": "secret"}
        steps = matcher._generic_steps(vuln)
        assert any("rotate" in s.lower() for s in steps)

    def test_iac_vuln_steps(self, matcher: PlaybookMatcher):
        vuln = {"severity": "medium", "cve_id": "", "scanner_type": "iac"}
        steps = matcher._generic_steps(vuln)
        assert any("iac" in s.lower() or "template" in s.lower() for s in steps)

    def test_network_vuln_steps(self, matcher: PlaybookMatcher):
        vuln = {"severity": "high", "cve_id": "", "scanner_type": "network"}
        steps = matcher._generic_steps(vuln)
        assert any("firewall" in s.lower() or "security group" in s.lower() for s in steps)

    def test_unknown_scanner_steps(self, matcher: PlaybookMatcher):
        vuln = {"severity": "low", "cve_id": "", "scanner_type": "other"}
        steps = matcher._generic_steps(vuln)
        assert any("investigate" in s.lower() for s in steps)
        # Low severity should not include audit/document step
        assert not any("document" in s.lower() for s in steps)

    def test_high_severity_includes_documentation(self, matcher: PlaybookMatcher):
        vuln = {"severity": "high", "cve_id": "CVE-2024-0001", "scanner_type": ""}
        steps = matcher._generic_steps(vuln)
        assert any("document" in s.lower() for s in steps)
