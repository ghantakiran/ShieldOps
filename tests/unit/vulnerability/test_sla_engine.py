"""Tests for the SLA enforcement engine.

Tests cover:
- SLA due date calculation with defaults and overrides
- SLA compliance checking (compliant, breached, closed)
- Breach detection with multiplier and overdue hours
- Bulk SLA check across all open vulnerabilities
"""

from datetime import UTC, datetime, timedelta
from typing import Any
from unittest.mock import AsyncMock

import pytest

from shieldops.vulnerability.sla_engine import DEFAULT_SLAS, SLAEngine


def _make_vuln(
    status: str = "new",
    severity: str = "high",
    first_seen_at: str | None = None,
    sla_due_at: str | datetime | None = None,
    sla_breached: bool = False,
) -> dict[str, Any]:
    result: dict[str, Any] = {
        "id": "vuln-001",
        "status": status,
        "severity": severity,
        "sla_breached": sla_breached,
    }
    if first_seen_at:
        result["first_seen_at"] = first_seen_at
    if sla_due_at:
        result["sla_due_at"] = sla_due_at
    return result


@pytest.fixture
def engine() -> SLAEngine:
    return SLAEngine()


@pytest.fixture
def custom_engine() -> SLAEngine:
    return SLAEngine(sla_overrides={"critical": timedelta(hours=12)})


@pytest.fixture
def engine_with_repo() -> tuple[SLAEngine, AsyncMock]:
    repo = AsyncMock()
    engine = SLAEngine(repository=repo)
    return engine, repo


# ============================================================================
# Default SLAs
# ============================================================================


class TestDefaultSLAs:
    def test_critical_24_hours(self) -> None:
        assert DEFAULT_SLAS["critical"] == timedelta(hours=24)

    def test_high_72_hours(self) -> None:
        assert DEFAULT_SLAS["high"] == timedelta(hours=72)

    def test_medium_7_days(self) -> None:
        assert DEFAULT_SLAS["medium"] == timedelta(days=7)

    def test_low_30_days(self) -> None:
        assert DEFAULT_SLAS["low"] == timedelta(days=30)


# ============================================================================
# Calculate SLA due date
# ============================================================================


class TestCalculateSLADueDate:
    def test_critical_due_date(self, engine: SLAEngine) -> None:
        base = datetime(2024, 6, 1, 12, 0, 0, tzinfo=UTC)
        due = engine.calculate_sla_due_date("critical", base)
        assert due == base + timedelta(hours=24)

    def test_high_due_date(self, engine: SLAEngine) -> None:
        base = datetime(2024, 6, 1, 12, 0, 0, tzinfo=UTC)
        due = engine.calculate_sla_due_date("high", base)
        assert due == base + timedelta(hours=72)

    def test_unknown_severity_defaults_to_medium(self, engine: SLAEngine) -> None:
        base = datetime(2024, 6, 1, 12, 0, 0, tzinfo=UTC)
        due = engine.calculate_sla_due_date("unknown", base)
        assert due == base + timedelta(days=7)

    def test_uses_current_time_when_no_created_at(self, engine: SLAEngine) -> None:
        before = datetime.now(UTC)
        due = engine.calculate_sla_due_date("critical")
        after = datetime.now(UTC)
        # Due date should be between now+24h (bounded by before/after)
        assert before + timedelta(hours=24) <= due <= after + timedelta(hours=24)

    def test_custom_override(self, custom_engine: SLAEngine) -> None:
        base = datetime(2024, 6, 1, 12, 0, 0, tzinfo=UTC)
        due = custom_engine.calculate_sla_due_date("critical", base)
        assert due == base + timedelta(hours=12)


# ============================================================================
# Check SLA compliance
# ============================================================================


class TestCheckSLACompliance:
    def test_closed_vuln_always_compliant(self, engine: SLAEngine) -> None:
        vuln = _make_vuln(status="closed")
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True
        assert result["breached"] is False

    def test_verified_vuln_always_compliant(self, engine: SLAEngine) -> None:
        vuln = _make_vuln(status="verified")
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True

    def test_accepted_risk_always_compliant(self, engine: SLAEngine) -> None:
        vuln = _make_vuln(status="accepted_risk")
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True

    def test_compliant_within_sla(self, engine: SLAEngine) -> None:
        # SLA due in the future
        future = (datetime.now(UTC) + timedelta(hours=10)).isoformat()
        vuln = _make_vuln(status="new", sla_due_at=future)
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True
        assert result["breached"] is False
        assert result["time_remaining_hours"] > 0

    def test_breached_past_sla(self, engine: SLAEngine) -> None:
        # SLA due in the past
        past = (datetime.now(UTC) - timedelta(hours=5)).isoformat()
        vuln = _make_vuln(status="new", severity="high", sla_due_at=past)
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is False
        assert result["breached"] is True
        assert result["time_overdue_hours"] > 0
        assert result["breach_multiplier"] > 0

    def test_no_sla_date_and_no_first_seen(self, engine: SLAEngine) -> None:
        vuln = _make_vuln(status="new")
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True
        assert result["reason"] == "no_sla_date"

    def test_sla_calculated_from_first_seen(self, engine: SLAEngine) -> None:
        # first_seen_at far in the past should breach
        old_time = (datetime.now(UTC) - timedelta(days=60)).isoformat()
        vuln = _make_vuln(status="new", severity="critical", first_seen_at=old_time)
        result = engine.check_sla_compliance(vuln)
        assert result["breached"] is True

    def test_sla_due_as_datetime_object(self, engine: SLAEngine) -> None:
        future = datetime.now(UTC) + timedelta(hours=10)
        vuln = _make_vuln(status="new", sla_due_at=future)
        result = engine.check_sla_compliance(vuln)
        assert result["compliant"] is True

    def test_breach_multiplier_calculation(self, engine: SLAEngine) -> None:
        # Breach by exactly 1 SLA window for high (72h)
        sla_due = datetime.now(UTC) - timedelta(hours=72)
        vuln = _make_vuln(status="new", severity="high", sla_due_at=sla_due.isoformat())
        result = engine.check_sla_compliance(vuln)
        # Multiplier should be approximately 1.0
        assert result["breach_multiplier"] == pytest.approx(1.0, abs=0.1)


# ============================================================================
# Check all SLA compliance (bulk)
# ============================================================================


class TestCheckAllSLACompliance:
    @pytest.mark.asyncio
    async def test_checks_open_vulns(self) -> None:
        engine, repo = engine_with_repo_fixture()
        past_sla = (datetime.now(UTC) - timedelta(hours=5)).isoformat()
        repo.list_vulnerabilities = AsyncMock(
            return_value=[
                _make_vuln(status="new", severity="critical", sla_due_at=past_sla),
            ]
        )
        repo.update_vulnerability_status = AsyncMock(return_value=True)

        result = await engine.check_all_sla_compliance()

        assert result["checked"] >= 1
        assert result["newly_breached"] >= 1
        repo.update_vulnerability_status.assert_called()

    @pytest.mark.asyncio
    async def test_skips_already_breached(self) -> None:
        engine, repo = engine_with_repo_fixture()
        past_sla = (datetime.now(UTC) - timedelta(hours=5)).isoformat()
        repo.list_vulnerabilities = AsyncMock(
            return_value=[
                _make_vuln(
                    status="new",
                    severity="critical",
                    sla_due_at=past_sla,
                    sla_breached=True,
                ),
            ]
        )

        result = await engine.check_all_sla_compliance()

        # Already marked as breached, so newly_breached should be 0
        assert result["newly_breached"] == 0
        repo.update_vulnerability_status.assert_not_called()

    @pytest.mark.asyncio
    async def test_no_repo_returns_error(self) -> None:
        engine = SLAEngine()
        result = await engine.check_all_sla_compliance()
        assert result["error"] == "no repository"

    @pytest.mark.asyncio
    async def test_compliant_vulns_not_updated(self) -> None:
        engine, repo = engine_with_repo_fixture()
        future_sla = (datetime.now(UTC) + timedelta(hours=10)).isoformat()
        repo.list_vulnerabilities = AsyncMock(
            return_value=[
                _make_vuln(status="new", severity="high", sla_due_at=future_sla),
            ]
        )

        result = await engine.check_all_sla_compliance()

        assert result["newly_breached"] == 0
        repo.update_vulnerability_status.assert_not_called()


# ============================================================================
# Helpers
# ============================================================================


def engine_with_repo_fixture() -> tuple[SLAEngine, AsyncMock]:
    repo = AsyncMock()
    return SLAEngine(repository=repo), repo
