"""Tests for SecurityNewsletterService — periodic vulnerability digests.

Covers:
- Service initialization
- generate_daily_digest — sections generated, data gathered
- generate_weekly_digest — more comprehensive sections
- send_digest — dispatcher called with correct args
- send_digest — no dispatcher returns sent=False
- send_digest — resolves recipients from team when not provided
- preview — returns digest without sending
- HTML rendering (fallback when template missing)
- Plain text rendering
- Per-team filtering via NewsletterConfig.team_id
- Error handling in data gathering methods
"""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from types import SimpleNamespace
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from shieldops.vulnerability.newsletter import (
    NewsletterConfig,
    NewsletterSection,
    SecurityNewsletterService,
)

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _make_vuln(
    vuln_id="vuln-1",
    cve_id="CVE-2024-0001",
    severity="critical",
    description="Test vuln",
    affected_resource="server-1",
    status="new",
    first_seen_at=None,
    sla_due_at=None,
):
    """Create a mock vulnerability object with attributes (not a dict)."""
    v = SimpleNamespace(
        id=vuln_id,
        cve_id=cve_id,
        severity=severity,
        description=description,
        affected_resource=affected_resource,
        status=status,
        first_seen_at=first_seen_at or datetime.now(UTC) - timedelta(hours=12),
        sla_due_at=sla_due_at,
    )
    return v


def _make_scan(posture_score=85):
    return SimpleNamespace(posture_score=posture_score)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture()
def mock_repository() -> AsyncMock:
    repo = AsyncMock()
    repo.list_vulnerabilities = AsyncMock(
        return_value=[
            _make_vuln("vuln-1", severity="critical"),
            _make_vuln("vuln-2", severity="high"),
        ]
    )
    repo.get_vulnerability_stats = AsyncMock(
        return_value={
            "total_open": 15,
            "remediated": 5,
            "verified": 3,
            "closed": 2,
            "accepted_risk": 1,
            "mttr_hours": 48,
        }
    )
    repo.list_security_scans = AsyncMock(
        return_value=[
            _make_scan(80),
            _make_scan(85),
        ]
    )
    repo.get_team = AsyncMock(return_value=None)
    return repo


@pytest.fixture()
def mock_dispatcher() -> AsyncMock:
    return AsyncMock()


@pytest.fixture()
def service(mock_repository, mock_dispatcher) -> SecurityNewsletterService:
    # Patch jinja2 Environment so it doesn't try to find a real package
    with patch("shieldops.vulnerability.newsletter.Environment") as mock_env_cls:
        mock_env_cls.return_value = MagicMock()
        svc = SecurityNewsletterService(
            repository=mock_repository,
            notification_dispatcher=mock_dispatcher,
        )
    return svc


@pytest.fixture()
def service_no_dispatcher(mock_repository) -> SecurityNewsletterService:
    with patch("shieldops.vulnerability.newsletter.Environment") as mock_env_cls:
        mock_env_cls.return_value = MagicMock()
        svc = SecurityNewsletterService(
            repository=mock_repository,
            notification_dispatcher=None,
        )
    return svc


# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------


class TestNewsletterServiceInit:
    """Service construction."""

    def test_init_stores_dependencies(self, service: SecurityNewsletterService):
        assert service._repository is not None
        assert service._dispatcher is not None

    def test_init_without_dispatcher(self, service_no_dispatcher: SecurityNewsletterService):
        assert service_no_dispatcher._dispatcher is None


class TestGenerateDailyDigest:
    """generate_daily_digest produces a well-structured digest."""

    @pytest.mark.asyncio
    async def test_daily_digest_has_required_fields(self, service: SecurityNewsletterService):
        digest = await service.generate_daily_digest()
        assert digest["frequency"] == "daily"
        assert "generated_at" in digest
        assert "period_start" in digest
        assert "sections" in digest
        assert isinstance(digest["sections"], list)

    @pytest.mark.asyncio
    async def test_daily_digest_includes_new_vulns_section(
        self, service: SecurityNewsletterService
    ):
        digest = await service.generate_daily_digest()
        section_titles = [s["title"] for s in digest["sections"]]
        assert "New Vulnerabilities" in section_titles

    @pytest.mark.asyncio
    async def test_daily_digest_includes_remediation_progress(
        self, service: SecurityNewsletterService
    ):
        digest = await service.generate_daily_digest()
        section_titles = [s["title"] for s in digest["sections"]]
        assert "Remediation Progress" in section_titles

    @pytest.mark.asyncio
    async def test_daily_digest_has_html_and_plain_text(self, service: SecurityNewsletterService):
        digest = await service.generate_daily_digest()
        assert "html" in digest
        assert "plain_text" in digest


class TestGenerateWeeklyDigest:
    """generate_weekly_digest for longer reporting period."""

    @pytest.mark.asyncio
    async def test_weekly_digest_frequency(self, service: SecurityNewsletterService):
        digest = await service.generate_weekly_digest()
        assert digest["frequency"] == "weekly"

    @pytest.mark.asyncio
    async def test_weekly_digest_includes_posture_section(self, service: SecurityNewsletterService):
        digest = await service.generate_weekly_digest()
        section_titles = [s["title"] for s in digest["sections"]]
        assert "Security Posture" in section_titles


class TestSendDigest:
    """send_digest dispatches via notification channel."""

    @pytest.mark.asyncio
    async def test_sends_to_explicit_recipients(
        self, service: SecurityNewsletterService, mock_dispatcher: AsyncMock
    ):
        digest = await service.generate_daily_digest()
        result = await service.send_digest(digest, recipients=["alice@test.com", "bob@test.com"])
        assert result["sent"] is True
        assert result["recipients"] == 2
        mock_dispatcher.send_notification.assert_awaited_once()
        call_kwargs = mock_dispatcher.send_notification.call_args.kwargs
        assert call_kwargs["channel"] == "email"
        assert len(call_kwargs["recipients"]) == 2

    @pytest.mark.asyncio
    async def test_returns_false_when_no_dispatcher(
        self, service_no_dispatcher: SecurityNewsletterService
    ):
        digest = {"frequency": "daily"}
        result = await service_no_dispatcher.send_digest(digest, recipients=["a@b.com"])
        assert result["sent"] is False
        assert result["reason"] == "no dispatcher configured"

    @pytest.mark.asyncio
    async def test_returns_false_when_no_recipients(self, service: SecurityNewsletterService):
        digest = {"frequency": "daily"}
        result = await service.send_digest(digest)
        assert result["sent"] is False
        assert result["reason"] == "no recipients"

    @pytest.mark.asyncio
    async def test_resolves_recipients_from_team(
        self,
        service: SecurityNewsletterService,
        mock_repository: AsyncMock,
        mock_dispatcher: AsyncMock,
    ):
        team = SimpleNamespace(
            members=[
                SimpleNamespace(email="lead@test.com"),
                SimpleNamespace(email="dev@test.com"),
            ]
        )
        mock_repository.get_team.return_value = team
        digest = {"frequency": "weekly", "html": "<p>test</p>"}
        result = await service.send_digest(digest, team_id="team-sec")
        assert result["sent"] is True
        assert result["recipients"] == 2

    @pytest.mark.asyncio
    async def test_handles_dispatcher_exception(
        self, service: SecurityNewsletterService, mock_dispatcher: AsyncMock
    ):
        mock_dispatcher.send_notification.side_effect = RuntimeError("SMTP down")
        digest = {"frequency": "daily"}
        result = await service.send_digest(digest, recipients=["x@y.com"])
        assert result["sent"] is False
        assert "error" in result


class TestPreview:
    """preview returns a digest without sending."""

    @pytest.mark.asyncio
    async def test_preview_daily(self, service: SecurityNewsletterService):
        digest = await service.preview(frequency="daily")
        assert digest["frequency"] == "daily"

    @pytest.mark.asyncio
    async def test_preview_weekly(self, service: SecurityNewsletterService):
        digest = await service.preview(frequency="weekly")
        assert digest["frequency"] == "weekly"


class TestTeamFiltering:
    """Per-team filtering through NewsletterConfig.team_id."""

    @pytest.mark.asyncio
    async def test_digest_passes_team_id_to_repo(
        self, service: SecurityNewsletterService, mock_repository: AsyncMock
    ):
        config = NewsletterConfig(frequency="daily", team_id="team-sec")
        digest = await service.generate_daily_digest(config=config)
        assert digest["team_id"] == "team-sec"
        # Verify repository was called with team_id
        calls = mock_repository.list_vulnerabilities.call_args_list
        assert any(c.kwargs.get("team_id") == "team-sec" for c in calls), (
            "Repository should be called with team_id filter"
        )


class TestRendering:
    """HTML and plain text rendering."""

    def test_fallback_html_renders_sections(self, service: SecurityNewsletterService):
        digest = {
            "sections": [
                {"title": "New Vulnerabilities", "content": {"total": 5}},
            ],
            "period_start": "2024-01-01T00:00:00",
            "period_end": "2024-01-02T00:00:00",
        }
        html = service._render_fallback_html(digest)
        assert "<html>" in html
        assert "New Vulnerabilities" in html
        assert "ShieldOps Security Digest" in html

    def test_plain_text_renders_all_sections(self, service: SecurityNewsletterService):
        digest = {
            "sections": [
                {"title": "SLA Status", "content": {"breached": 3}},
                {"title": "Top Risks", "content": {"risks": [{"id": "v1"}]}},
            ],
            "period_start": "2024-01-01",
            "period_end": "2024-01-02",
        }
        text = service._render_plain_text(digest)
        assert "SLA Status" in text
        assert "Top Risks" in text
        assert "ShieldOps Security Digest" in text

    def test_html_falls_back_when_template_missing(self, service: SecurityNewsletterService):
        # The jinja_env is mocked, so get_template will fail — triggering fallback
        service._jinja_env.get_template.side_effect = Exception("template not found")
        digest = {
            "sections": [{"title": "Test", "content": {}}],
            "period_start": "2024-01-01",
            "period_end": "2024-01-02",
        }
        html = service._render_html(digest, "daily")
        assert "<html>" in html  # fallback HTML was used


class TestDataGatheringErrors:
    """Error handling in internal data-gathering methods."""

    @pytest.mark.asyncio
    async def test_new_vulns_returns_empty_on_error(
        self, service: SecurityNewsletterService, mock_repository: AsyncMock
    ):
        mock_repository.list_vulnerabilities.side_effect = RuntimeError("DB error")
        config = NewsletterConfig()
        result = await service._get_new_vulnerabilities(datetime.now(UTC), config)
        assert result["total"] == 0

    @pytest.mark.asyncio
    async def test_sla_breaches_returns_empty_on_error(
        self, service: SecurityNewsletterService, mock_repository: AsyncMock
    ):
        mock_repository.list_vulnerabilities.side_effect = RuntimeError("DB error")
        config = NewsletterConfig()
        result = await service._get_sla_breaches(config)
        assert result["breached"] == 0

    @pytest.mark.asyncio
    async def test_posture_trend_returns_unknown_on_error(
        self, service: SecurityNewsletterService, mock_repository: AsyncMock
    ):
        mock_repository.list_security_scans.side_effect = RuntimeError("DB error")
        result = await service._get_posture_trend(datetime.now(UTC))
        assert result["trend"] == "unknown"

    @pytest.mark.asyncio
    async def test_top_risks_returns_empty_on_error(
        self, service: SecurityNewsletterService, mock_repository: AsyncMock
    ):
        mock_repository.list_vulnerabilities.side_effect = RuntimeError("DB error")
        config = NewsletterConfig()
        result = await service._get_top_risks(config)
        assert result == []


class TestNewsletterSection:
    """NewsletterSection data class."""

    def test_section_stores_fields(self):
        section = NewsletterSection(title="Test", content={"key": "val"}, priority=2)
        assert section.title == "Test"
        assert section.content == {"key": "val"}
        assert section.priority == 2
