"""Tests for the vulnerability lifecycle state machine.

Tests cover:
- All valid state transitions
- All invalid state transitions
- Transition with repository integration
- Auto-verify remediated flow
- Deduplication
- WebSocket broadcast on transitions
- Timestamp setting (remediated_at, closed_at)
"""

from datetime import datetime
from typing import Any
from unittest.mock import AsyncMock

import pytest

from shieldops.vulnerability.lifecycle import (
    VALID_STATUSES,
    VALID_TRANSITIONS,
    VulnerabilityLifecycleManager,
)


def _make_vuln(
    vuln_id: str = "vuln-001",
    status: str = "new",
    scan_id: str = "scan-old",
) -> dict[str, Any]:
    return {
        "id": vuln_id,
        "status": status,
        "scan_id": scan_id,
        "severity": "high",
    }


@pytest.fixture
def mock_repo() -> AsyncMock:
    repo = AsyncMock()
    repo.get_vulnerability = AsyncMock(return_value=_make_vuln())
    repo.update_vulnerability_status = AsyncMock(return_value=True)
    repo.add_vulnerability_comment = AsyncMock(return_value="c-1")
    repo.list_vulnerabilities = AsyncMock(return_value=[])
    return repo


@pytest.fixture
def mock_ws() -> AsyncMock:
    return AsyncMock()


@pytest.fixture
def mgr(mock_repo: AsyncMock, mock_ws: AsyncMock) -> VulnerabilityLifecycleManager:
    return VulnerabilityLifecycleManager(repository=mock_repo, ws_manager=mock_ws)


# ============================================================================
# Status and transition constants
# ============================================================================


class TestConstants:
    def test_all_statuses_present(self) -> None:
        expected = {
            "new",
            "triaged",
            "in_progress",
            "remediated",
            "verified",
            "closed",
            "accepted_risk",
        }
        assert expected == VALID_STATUSES

    def test_every_status_has_transitions(self) -> None:
        for s in VALID_STATUSES:
            assert s in VALID_TRANSITIONS, f"Missing transitions for status '{s}'"

    def test_all_transition_targets_are_valid(self) -> None:
        for source, targets in VALID_TRANSITIONS.items():
            for target in targets:
                assert target in VALID_STATUSES, (
                    f"Transition target '{target}' from '{source}' is not in VALID_STATUSES"
                )


# ============================================================================
# validate_transition - all valid paths
# ============================================================================


class TestValidTransitions:
    @pytest.mark.parametrize(
        "current,new_status",
        [
            ("new", "triaged"),
            ("new", "in_progress"),
            ("new", "accepted_risk"),
            ("triaged", "in_progress"),
            ("triaged", "accepted_risk"),
            ("in_progress", "remediated"),
            ("in_progress", "accepted_risk"),
            ("remediated", "verified"),
            ("remediated", "in_progress"),
            ("verified", "closed"),
            ("verified", "in_progress"),
            ("closed", "new"),
            ("accepted_risk", "new"),
            ("accepted_risk", "triaged"),
        ],
    )
    def test_valid_transition(
        self, mgr: VulnerabilityLifecycleManager, current: str, new_status: str
    ) -> None:
        valid, msg = mgr.validate_transition(current, new_status)
        assert valid is True, f"Expected {current}->{new_status} to be valid, got: {msg}"
        assert msg == ""


# ============================================================================
# validate_transition - invalid paths
# ============================================================================


class TestInvalidTransitions:
    @pytest.mark.parametrize(
        "current,new_status",
        [
            ("new", "closed"),
            ("new", "verified"),
            ("new", "remediated"),
            ("triaged", "closed"),
            ("triaged", "remediated"),
            ("triaged", "verified"),
            ("in_progress", "new"),
            ("in_progress", "triaged"),
            ("in_progress", "closed"),
            ("remediated", "new"),
            ("remediated", "closed"),
            ("remediated", "accepted_risk"),
            ("verified", "new"),
            ("verified", "remediated"),
            ("closed", "in_progress"),
            ("closed", "triaged"),
        ],
    )
    def test_invalid_transition(
        self, mgr: VulnerabilityLifecycleManager, current: str, new_status: str
    ) -> None:
        valid, msg = mgr.validate_transition(current, new_status)
        assert valid is False, f"Expected {current}->{new_status} to be invalid"
        assert "Cannot transition" in msg

    def test_invalid_target_status(self, mgr: VulnerabilityLifecycleManager) -> None:
        valid, msg = mgr.validate_transition("new", "bogus_status")
        assert valid is False
        assert "Invalid status" in msg


# ============================================================================
# Execute transition
# ============================================================================


class TestExecuteTransition:
    @pytest.mark.asyncio
    async def test_happy_path(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        result = await mgr.transition("vuln-001", "triaged", user_id="u1", reason="Reviewed")

        assert result["success"] is True
        assert result["from_status"] == "new"
        assert result["to_status"] == "triaged"

    @pytest.mark.asyncio
    async def test_no_repository(self) -> None:
        mgr = VulnerabilityLifecycleManager()
        result = await mgr.transition("v1", "triaged")
        assert result == {"success": False, "error": "no repository"}

    @pytest.mark.asyncio
    async def test_vuln_not_found(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = None
        result = await mgr.transition("missing", "triaged")
        assert result == {"success": False, "error": "not found"}

    @pytest.mark.asyncio
    async def test_invalid_transition_rejected(self, mgr: VulnerabilityLifecycleManager) -> None:
        result = await mgr.transition("vuln-001", "closed")
        assert result["success"] is False
        assert "Cannot transition" in result["error"]

    @pytest.mark.asyncio
    async def test_update_failure(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.update_vulnerability_status.return_value = False
        result = await mgr.transition("vuln-001", "triaged")
        assert result == {"success": False, "error": "update failed"}

    @pytest.mark.asyncio
    async def test_remediated_sets_remediated_at(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = _make_vuln(status="in_progress")
        await mgr.transition("vuln-001", "remediated")
        kwargs = mock_repo.update_vulnerability_status.call_args.kwargs
        assert "remediated_at" in kwargs
        assert isinstance(kwargs["remediated_at"], datetime)

    @pytest.mark.asyncio
    async def test_closed_sets_closed_at(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = _make_vuln(status="verified")
        await mgr.transition("vuln-001", "closed")
        kwargs = mock_repo.update_vulnerability_status.call_args.kwargs
        assert "closed_at" in kwargs

    @pytest.mark.asyncio
    async def test_comment_logged(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        await mgr.transition("vuln-001", "triaged", user_id="u1", reason="Triaged by team")
        mock_repo.add_vulnerability_comment.assert_called_once()
        kwargs = mock_repo.add_vulnerability_comment.call_args.kwargs
        assert kwargs["comment_type"] == "status_change"
        assert "Triaged by team" in kwargs["content"]
        assert kwargs["user_id"] == "u1"

    @pytest.mark.asyncio
    async def test_ws_broadcast(
        self, mgr: VulnerabilityLifecycleManager, mock_ws: AsyncMock
    ) -> None:
        await mgr.transition("vuln-001", "triaged")
        mock_ws.broadcast.assert_called_once()
        msg = mock_ws.broadcast.call_args.kwargs["message"]
        assert msg["type"] == "vulnerability_status_changed"
        assert msg["from_status"] == "new"
        assert msg["to_status"] == "triaged"

    @pytest.mark.asyncio
    async def test_no_ws_manager_does_not_crash(self, mock_repo: AsyncMock) -> None:
        mgr = VulnerabilityLifecycleManager(repository=mock_repo, ws_manager=None)
        result = await mgr.transition("vuln-001", "triaged")
        assert result["success"] is True


# ============================================================================
# Auto-verify remediated
# ============================================================================


class TestAutoVerifyRemediated:
    @pytest.mark.asyncio
    async def test_verifies_and_closes(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.list_vulnerabilities.return_value = [
            _make_vuln(status="remediated", scan_id="scan-old"),
        ]

        call_idx = 0

        async def get_side_effect(vid: str) -> dict[str, Any]:
            nonlocal call_idx
            call_idx += 1
            if call_idx == 1:
                return _make_vuln(status="remediated")
            return _make_vuln(status="verified")

        mock_repo.get_vulnerability = AsyncMock(side_effect=get_side_effect)

        result = await mgr.auto_verify_remediated("scan-new")
        assert result["verified"] == 1
        assert result["closed"] == 1

    @pytest.mark.asyncio
    async def test_skips_when_scan_matches(
        self, mgr: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.list_vulnerabilities.return_value = [
            _make_vuln(status="remediated", scan_id="scan-new"),
        ]

        result = await mgr.auto_verify_remediated("scan-new")
        assert result["verified"] == 0

    @pytest.mark.asyncio
    async def test_no_repo(self) -> None:
        mgr = VulnerabilityLifecycleManager()
        result = await mgr.auto_verify_remediated("scan-new")
        assert result == {"verified": 0, "closed": 0}


# ============================================================================
# Deduplication
# ============================================================================


class TestDeduplicate:
    @pytest.mark.asyncio
    async def test_returns_zero(self, mgr: VulnerabilityLifecycleManager) -> None:
        result = await mgr.deduplicate_findings()
        assert result == {"deduplicated": 0}

    @pytest.mark.asyncio
    async def test_no_repo(self) -> None:
        mgr = VulnerabilityLifecycleManager()
        result = await mgr.deduplicate_findings()
        assert result == {"deduplicated": 0}
