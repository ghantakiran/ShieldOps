"""Tests for vulnerability lifecycle management (security agent perspective).

Tests cover:
- State machine transitions (valid and invalid)
- Auto-verify/auto-close flow after remediation scan
- Deduplication logic
- WebSocket event emission on transition
- Repository integration points
"""

from typing import Any
from unittest.mock import AsyncMock

import pytest

from shieldops.vulnerability.lifecycle import (
    VALID_STATUSES,
    VALID_TRANSITIONS,
    VulnerabilityLifecycleManager,
)


def _make_vuln(
    vuln_id: str = "vuln-001",
    status: str = "new",
    scan_id: str = "scan-old",
    **extra: Any,
) -> dict[str, Any]:
    return {
        "id": vuln_id,
        "status": status,
        "scan_id": scan_id,
        "severity": "high",
        "cve_id": "CVE-2024-1234",
        "affected_resource": "nginx:1.25",
        **extra,
    }


@pytest.fixture
def mock_repo() -> AsyncMock:
    repo = AsyncMock()
    repo.get_vulnerability = AsyncMock(return_value=_make_vuln())
    repo.update_vulnerability_status = AsyncMock(return_value=True)
    repo.add_vulnerability_comment = AsyncMock(return_value="comment-1")
    repo.list_vulnerabilities = AsyncMock(return_value=[])
    return repo


@pytest.fixture
def mock_ws() -> AsyncMock:
    return AsyncMock()


@pytest.fixture
def manager(mock_repo: AsyncMock, mock_ws: AsyncMock) -> VulnerabilityLifecycleManager:
    return VulnerabilityLifecycleManager(repository=mock_repo, ws_manager=mock_ws)


@pytest.fixture
def manager_no_repo() -> VulnerabilityLifecycleManager:
    return VulnerabilityLifecycleManager(repository=None, ws_manager=None)


# ============================================================================
# Validate transition
# ============================================================================


class TestValidateTransition:
    def test_valid_new_to_triaged(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, msg = manager.validate_transition("new", "triaged")
        assert valid is True
        assert msg == ""

    def test_valid_new_to_in_progress(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, _ = manager.validate_transition("new", "in_progress")
        assert valid is True

    def test_invalid_new_to_closed(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, msg = manager.validate_transition("new", "closed")
        assert valid is False
        assert "Cannot transition" in msg

    def test_invalid_status_rejected(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, msg = manager.validate_transition("new", "nonexistent")
        assert valid is False
        assert "Invalid status" in msg

    def test_closed_can_reopen_to_new(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, _ = manager.validate_transition("closed", "new")
        assert valid is True

    def test_accepted_risk_can_revoke(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, _ = manager.validate_transition("accepted_risk", "triaged")
        assert valid is True

    def test_remediated_to_verified(self, manager: VulnerabilityLifecycleManager) -> None:
        valid, _ = manager.validate_transition("remediated", "verified")
        assert valid is True

    def test_all_transitions_covered(self) -> None:
        """Every status in VALID_STATUSES appears as a key in VALID_TRANSITIONS."""
        for status in VALID_STATUSES:
            assert status in VALID_TRANSITIONS


# ============================================================================
# Execute transition
# ============================================================================


class TestTransition:
    @pytest.mark.asyncio
    async def test_successful_transition(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        result = await manager.transition("vuln-001", "triaged", user_id="user-1")
        assert result["success"] is True
        assert result["from_status"] == "new"
        assert result["to_status"] == "triaged"
        mock_repo.update_vulnerability_status.assert_called_once()
        mock_repo.add_vulnerability_comment.assert_called_once()

    @pytest.mark.asyncio
    async def test_transition_not_found(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = None
        result = await manager.transition("vuln-missing", "triaged")
        assert result["success"] is False
        assert result["error"] == "not found"

    @pytest.mark.asyncio
    async def test_transition_invalid_rejected(
        self, manager: VulnerabilityLifecycleManager
    ) -> None:
        result = await manager.transition("vuln-001", "closed")
        assert result["success"] is False
        assert "Cannot transition" in result["error"]

    @pytest.mark.asyncio
    async def test_transition_update_failure(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.update_vulnerability_status.return_value = False
        result = await manager.transition("vuln-001", "triaged")
        assert result["success"] is False
        assert result["error"] == "update failed"

    @pytest.mark.asyncio
    async def test_no_repo_returns_error(
        self, manager_no_repo: VulnerabilityLifecycleManager
    ) -> None:
        result = await manager_no_repo.transition("vuln-001", "triaged")
        assert result["success"] is False
        assert result["error"] == "no repository"

    @pytest.mark.asyncio
    async def test_remediated_sets_timestamp(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = _make_vuln(status="in_progress")
        await manager.transition("vuln-001", "remediated")

        call_kwargs = mock_repo.update_vulnerability_status.call_args
        assert "remediated_at" in call_kwargs.kwargs

    @pytest.mark.asyncio
    async def test_closed_sets_timestamp(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        mock_repo.get_vulnerability.return_value = _make_vuln(status="verified")
        await manager.transition("vuln-001", "closed")

        call_kwargs = mock_repo.update_vulnerability_status.call_args
        assert "closed_at" in call_kwargs.kwargs

    @pytest.mark.asyncio
    async def test_websocket_broadcast_on_transition(
        self, manager: VulnerabilityLifecycleManager, mock_ws: AsyncMock
    ) -> None:
        await manager.transition("vuln-001", "triaged")
        mock_ws.broadcast.assert_called_once()
        broadcast_kwargs = mock_ws.broadcast.call_args
        msg = broadcast_kwargs.kwargs["message"]
        assert msg["type"] == "vulnerability_status_changed"

    @pytest.mark.asyncio
    async def test_reason_included_in_comment(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        await manager.transition("vuln-001", "triaged", reason="Looks important")
        comment_call = mock_repo.add_vulnerability_comment.call_args
        assert "Looks important" in comment_call.kwargs["content"]


# ============================================================================
# Auto-verify remediated
# ============================================================================


class TestAutoVerifyRemediated:
    @pytest.mark.asyncio
    async def test_auto_verify_and_close(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        remediated_vuln = _make_vuln(
            status="remediated",
            scan_id="scan-old",  # different from current scan
        )
        mock_repo.list_vulnerabilities.return_value = [remediated_vuln]

        # The transition calls get_vulnerability, so we sequence the returns
        call_count = 0

        async def get_vuln_side_effect(vid: str) -> dict[str, Any]:
            nonlocal call_count
            call_count += 1
            if call_count == 1:
                return _make_vuln(status="remediated")
            return _make_vuln(status="verified")

        mock_repo.get_vulnerability = AsyncMock(side_effect=get_vuln_side_effect)

        result = await manager.auto_verify_remediated("scan-new")

        assert result["verified"] == 1
        assert result["closed"] == 1

    @pytest.mark.asyncio
    async def test_auto_verify_no_repo(
        self, manager_no_repo: VulnerabilityLifecycleManager
    ) -> None:
        result = await manager_no_repo.auto_verify_remediated("scan-new")
        assert result == {"verified": 0, "closed": 0}

    @pytest.mark.asyncio
    async def test_auto_verify_skips_same_scan(
        self, manager: VulnerabilityLifecycleManager, mock_repo: AsyncMock
    ) -> None:
        # Vuln was found in the same scan, so it should NOT be verified
        vuln = _make_vuln(status="remediated", scan_id="scan-new")
        mock_repo.list_vulnerabilities.return_value = [vuln]

        result = await manager.auto_verify_remediated("scan-new")

        assert result["verified"] == 0
        assert result["closed"] == 0


# ============================================================================
# Deduplication
# ============================================================================


class TestDeduplication:
    @pytest.mark.asyncio
    async def test_dedup_returns_zero_by_default(
        self, manager: VulnerabilityLifecycleManager
    ) -> None:
        result = await manager.deduplicate_findings()
        assert result == {"deduplicated": 0}

    @pytest.mark.asyncio
    async def test_dedup_no_repo(self, manager_no_repo: VulnerabilityLifecycleManager) -> None:
        result = await manager_no_repo.deduplicate_findings()
        assert result == {"deduplicated": 0}
